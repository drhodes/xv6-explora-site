<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

    <title>xv6 explora: based on DRAFT 11</title>

    <!-- Explora CSS --> 
    <link rel="stylesheet" href="./css/pygments.css">
    <link rel="stylesheet" href="./css/explora.css">
    <style type="text/css" media="screen">
      
    </style>
  </head>
  <body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
      <a class="navbar-brand" href="#">xv6 explora (draft 11)</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse"
              data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      
      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav mr-auto">
          <li class="nav-item active">
            <a class="nav-link" href="https://github.com/mit-pdos/xv6-book/blob/master/LICENSE">Copyright<span class="sr-only">(current)</span></a>
          </li>
        </ul>
        <form class="form-inline my-2 my-lg-0">
          <input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search">
          <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
        </form>
      </div>
    </nav>
    
    <!-- Modal -->
    <div class="modal fade" id="exampleModalCenter" tabindex="-1" role="dialog" aria-labelledby="exampleModalCenterTitle" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="exampleModalLongTitle">Keyboard shortcuts</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body">
              <div id="table1"></div>            
              <table class="table table-sm">
                <tr> <td><b>Key</b></td> <td><b>Function</b></td> </tr>
                <tr><td>h or ?</td><td> Show these shortcuts </td></tr>
                <tr><td>esc</td><td> Hide these shortcuts / stop the voice </td></tr>
                <tr><td>j</td><td> Goto next sentence and speak it </td></tr>
                <tr><td>k</td><td> Goto previous sentence and speak it </td></tr>
                <tr><td>s</td><td> Speak sentence </td></tr>
                <tr><td>+</td><td> Speed up voice</td></tr>
                <tr><td>-</td><td> Slow down voice </td></tr>
              </table>
          </div>
          <!-- <div class="modal-footer"> -->
            <!--   <button type="button" class="btn btn-secondary" data-dismiss="modal">Done</button> -->
            <!-- </div> -->
        </div>
      </div>
    </div>

    <div class="container-fluid"> 
      <div class="row">
        <div id="editor-col" class="col-7">
          <div class="sticky-top">
            <div id="editor"> </div>
          </div>
        </div>
        <div id="book-col" class="col-5" >

          <div class="row sticky-top">
            <nav class="navbar navbar-expand-lg navbar-light bg-light sticky-top">
              <a class="navbar-brand" href="#">XV6 Explora</a>
              <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
              </button>
              <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                  
                  <li class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                      Chapters
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                      <a class="dropdown-item" href="#chapter0">Chapter 0 - Operating system interfaces</a>
                      <a class="dropdown-item" href="#chapter1">Chapter 1 - Operating system organization </a>
                      <a class="dropdown-item" href="#chapter2">Chapter 2 - Page Tables </a>
                      <a class="dropdown-item" href="#chapter3">Chapter 3 - Traps, interrupts and drivers </a>
                      <a class="dropdown-item" href="#chapter4">Chapter 4 - Locking </a>
                      <div class="dropdown-divider"></div>
                      <a class="dropdown-item" href="#">Appendixes</a>
                    </div>
                  </li>
                  <li class="nav-item active">
                    <a class="nav-link" href="" data-toggle="modal" data-target="#exampleModalCenter">Key Commands<span class="sr-only">(current)</span></a>
                  </li>

                  
                </ul>
              </div>
            </nav>
          </div>


          
          
          <div>
            <i> This website repackages a book and corresponding
              source code to xv6, each of which can be found through
              MIT's OpenCourseWare,
              <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/">
                Operating System Engineering.  
              </a>
          </i>
            <br><br>
            <i>Some features were added, which should save time for people across the board</i>
            <ul>
              <li>scroll-to function identifiers, globals, line numbers</li>
              <li>inline figure references</li>
              <li>inline assembly docs</li> 
              <li>text-to-speech with good keyboard control</li>
            </ul>
          <br/><br/><br/><br/>

          


<hr>
<div> <!-- chapter 0 -->
  <h1><a name="chapter0"></a></h1>
  <center><h1>CHAPTER 0</h1></center>
  <center><h1>Operating System Interfaces</h1></center>
  <p>
    The job of an operating system is to share a computer among multiple programs
    and to provide a more useful set of services than the hardware alone supports. The
    operating system manages and abstracts the low-level hardware, so that, for example, a
    word processor need not concern itself with which type of disk hardware is being
    used. It also shares the hardware among multiple programs so that they run (or appear
    to run) at the same time. Finally, operating systems provide controlled ways for
    programs to interact, so that they can share data or work together.
  </p>          
  <p>
    An operating system provides services to user programs through an
    interface.  Designing a good interface turns out to be difficult. On
    the one hand, we would like the interface to be simple and narrow
    because that makes it easier to get the implementation right. On the
    other hand, we may be tempted to offer many sophisticated features to
    applications. The trick in resolving this tension is to design
    interfaces that rely on a few mechanisms that can be combined to
    provide much generality.
  </p> 
  <p>  
    This book uses a single operating system as a concrete example to illustrate operating
    system concepts. That operating system, xv6, provides the basic interfaces introduced
    by Ken Thompson and Dennis Ritchie’s Unix operating system, as well as mimicking
    Unix’s internal design. Unix provides a narrow interface whose mechanisms
    combine well, offering a surprising degree of generality. This interface has been so
    successful that modern operating systems—BSD, Linux, Mac OS X, Solaris, and even,
    to a lesser extent, Microsoft Windows—have Unix-like interfaces. Understanding xv6
    is a good start toward understanding any of these systems and many others. </p>
  

  
    <br/>
    <img src="figs/fig0-1.jpg" alt="figure 0-1" class="img-thumbnail">
    <br>
    <br>
    <center>
      <b>Figure 0-1.</b>
      <small class="text-muted">figure 0-1</small>
    </center>
    <br><br>
    
  <br>
  
  <p>
    As shown in Figure 0-1, xv6 takes the traditional form of a kernel, a special program
    that provides services to running programs. Each running program, called a process,
    has memory containing instructions, data, and a stack. The instructions implement
    the program’s computation. The data are the variables on which the computation
    acts. The stack organizes the program’s procedure calls. </p>
  
  <p>
    When a process needs to invoke a kernel service, it invokes a procedure call in
    the operating system interface. Such a procedure is called a system call. The system
    call enters the kernel; the kernel performs the service and returns. Thus a process alternates
    between executing in user space and kernel space. </p>
  
  <p>
    The kernel uses the CPU’s hardware protection mechanisms
    to ensure that each process executing in user space can
    access only its own memory. The kernel executes with the
    hardware privileges required to implement these
    protections; user programs execute without those
    privileges. When a user program invokes a system call, the
    hardware raises the privilege level and starts executing a
    pre-arranged function in the kernel. </p>
  
  <p>
    The collection of system calls that a kernel provides is
    the interface that user programs see. The xv6 kernel
    provides a subset of the services and system calls that
    Unix kernels traditionally offer. Figure 0-2 lists all of
    xv6’s system calls. </p>
  
  <p>
    The rest of this chapter outlines xv6’s
    services—processes, memory, file descriptors, pipes, and
    file system—and illustrates them with code snippets and
    discussions of how the shell, which is the primary user
    interface to traditional Unix-like systems, uses them. The
    shell’s use of system calls illustrates how carefully they
    have been designed.  The shell is an ordinary program that
    reads commands from the user and executes them. The fact
    that the shell is a user program, not part of the kernel,
    illustrates the power of the system call interface: there
    is nothing special about the shell. It also means that the
    shell is easy to replace; as a result, modern Unix systems
    have a variety of shells to choose from, each with its own
    user interface and scripting features. The xv6 shell is a
    simple implementation of the essence of the Unix Bourne
    shell. Its implementation can be found at line <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8550);"><small>(8550)</small></a></code>.
  </p>

  <h3><p>§ Processes and memory</p></h3>
  
  <p>
    An xv6 process consists of user-space memory
    (instructions, data, and stack) and per-process state
    private to the kernel. Xv6 can time-share processes: it
    transparently switches the available CPUs among the set of
    processes waiting to execute. When a process is not
    executing, xv6 saves its CPU registers, restoring them when
    it next runs the process. The kernel associates a process
    identifier, or pid, with each process.
  </p>
  <p>
    A process may create a new process using the <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2580);">fork</a></code>  system
    call. Fork creates a new process, called the child process,
    with exactly the same memory contents as the calling
    process, called the parent process. Fork returns in both the
    parent and the child.  In the parent, fork returns the
    child’s pid; in the child, it returns zero. For example,
    consider the following program fragment:
  </p>
  
  <div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;parent: child=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
  <span class="n">pid</span> <span class="o">=</span> <span class="n">wait</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;child %d is done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;child: exiting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;fork error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>



  <p>
    The exit system call causes the calling process to stop
    executing and to release resources such as memory and open
    files. The wait system call returns the pid of an exited
    child of the current process; if none of the caller's
    children has exited, <code>wait</code> waits for one to do so. In the
    example, the output lines
  </p>

  <pre>
    parent: child=1234
    child: exiting
  </pre>
  
  <p>
    might come out in either order, depending on whether the parent or
    child gets to its printf call first. After the child exits the
    parent’s wait returns, causing the parent to print
  </p>

  <pre>
    parent: child 1234 is done
  </pre>
  
  <div id="table1"></div>            
  <table class="table table-sm">
    <tr> <td><b>System call</b></td> <td><b>Description</b></td> </tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2580);">fork</a></code></td><td> Create a process </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2627);">exit</a></code>()</td><td> Terminate the current process </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2671);">wait</a></code>()</td><td> Wait for a child process to exit </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2975);">kill</a></code>(pid)</td><td> Terminate process pid </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3789);">getpid</a></code>()</td><td> Return the current process’s pid </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2874);">sleep</a></code>(n)</td><td> Sleep for n clock ticks </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code>(filename, *argv)</td><td> Load a file and execute it </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3801);">sbrk</a></code>(n)</td><td> Grow process’s memory by n bytes </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6401);">open</a></code>(filename, flags)</td><td> Open a file; the flags indicate read/write </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6132);">read</a></code>(fd, buf, n)</td><td> Read n bytes from an open file into buf </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6151);">write</a></code>(fd, buf, n)</td><td> Write n bytes to an open file </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6163);">close</a></code>(fd)</td><td> Release open file fd </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6118);">dup</a></code>(fd)</td><td> Duplicate fd </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6762);">pipe</a></code>(p)</td><td> Create a pipe and return fd’s in p </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6501);">chdir</a></code>(dirname)</td><td> Change the current directory </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6451);">mkdir</a></code>(dirname)</td><td> Create a new directory </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6467);">mknod</a></code>(name, major, minor)</td><td> Create a device file </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6176);">fstat</a></code>(fd)</td><td> Return info about an open file </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6202);">link</a></code>(f1, f2)</td><td> Create another name (f2) for the file f1 </td></tr>
    <tr> <td><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6301);">unlink</a></code>(filename)</td><td> Remove a file </td></tr>
  </table>
  
  <hr>
  
  <p>Although the child has the same memory contents as the
    parent initially, the parent and child are executing with
    different memory and different registers: changing a
    variable in one does not affect the other. For example,
    when the return value of wait is stored into pid in the
    parent process, it doesn’t change the variable pid in the
    child.  The value of pid in the child will still be zero.
    The <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> system call replaces the calling process’s memory
    with a new memory image loaded from a file stored in the
    file system. The file must have a particular format, which
    specifies which part of the file holds instructions, which
    part is data, at which instruction to start, etc. xv6 uses
    the ELF format, which Chapter 2 discusses in more
    detail. When  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> succeeds, it does not return to the
    calling program; instead, the instructions loaded from the
    file start executing at the entry point declared in the
    ELF header.  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> takes two arguments: the name of the file
    containing the executable and an array of string
    arguments. For example:
  </p>

  <div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;echo&quot;</span><span class="p">;</span>
<span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">;</span>
<span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">exec</span><span class="p">(</span><span class="s">&quot;/bin/echo&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;exec error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>


  
  <p>
    This fragment replaces the calling program with an
    instance of the program /bin/echo running with the argument list echo
    hello. Most programs ignore the first argument, which is
    conventionally the name of the program.
  </p>

  <p>The xv6 shell uses the above calls to run programs on behalf of
    users. The main structure of the shell is simple; see main
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8701);"><small>(8701)</small></a></code>. The main loop reads a line of input from the user
    with getcmd. Then it calls <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2580);">fork</a></code> , which
    creates a copy of the shell process.  The parent calls wait, while
    the child runs the command. For example, if the user had typed
    ‘‘echo hello’’ to the shell, runcmd would have been called with
    ‘‘echo hello’’ as the argument. <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8606);">runcmd</a></code> runs the
    actual command. For ‘‘echo hello’’, it would call
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code>. If exec succeeds then the child will execute
    instructions from echo instead of <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8606);">runcmd</a></code>. At some
    point echo will call <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2627);">exit</a></code>, which will cause the
    parent to return from wait in <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1217);">main</a></code>. You might
    wonder why <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2580);">fork</a></code> and <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> are not combined in a single call; we
    will see later that separate calls for creating a process and
    loading a program is a clever design.</p>

  <p>
    Xv6 allocates most user-space memory implicitly: <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2580);">fork</a></code> 
    allocates the memory required for the child’s copy of the parent’s
    memory, and exec allocates enough memory to hold the executable
    file. A process that needs more memory at run-time (perhaps for
    malloc) can call sbrk(n) to grow its data memory by n bytes; sbrk
    returns the location of the new memory.</p>

  <p>Xv6 does not provide a notion of users or of protecting
    one user from another; in Unix terms, all xv6 processes run as root</p>

  <h4>I/O and File descriptors</h4>

  <p>A <i>file descriptor</i> is a small integer representing a
    kernel-managed object that a process may read from or write
    to. A process may obtain a file descriptor by opening a
    file, directory, or device, or by creating a pipe, or by
    duplicating an existing descriptor.  For simplicity we’ll
    often refer to the object a file descriptor refers to as a
    ‘‘file’’; the file descriptor interface abstracts away the
    differences between files, pipes, and devices, making them
    all look like streams of bytes.</p>

    <p>
      Internally, the xv6 kernel uses the file descriptor as an
      index into a per-process table, so that every process has a private
      space of file descriptors starting at zero. By convention, a process
      reads from file descriptor 0 (standard input), writes output to file
      descriptor 1 (standard output), and writes error messages to file
      descriptor 2 (standard error). As we will see, the shell exploits the
      convention to implement I/O redirection and pipelines. The shell
      ensures that it always has three file descriptors open<code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8707);"><small>(8707)</small></a></code>, which
      are by default file descriptors for the console.
    </p>
    
    <p>
      The read and write system calls read bytes from and write
      bytes to open files named by file descriptors. The
      call <code>read(fd, buf, n)</code> reads at most n bytes
      from the file descriptor fd, copies them into buf, and
      returns the number of bytes read. Each file descriptor
      that refers to a file has an offset associated with
      it. Read reads data from the current file offset and then
      advances that offset by the number of bytes read: a
      subsequent read will return the bytes following the ones
      returned by the first read.  When there are no more bytes
      to read, read returns zero to signal the end of the file.
    </p>
  
  <p>
    The call <code>write(fd, buf, n)</code> writes n bytes from buf to
    the file descriptor fd and returns the number of bytes
    written. Fewer than n bytes are written only when an error
    occurs. Like read, write writes data at the current file offset
    and then advances that offset by the number of bytes written: each
    write picks up where the previous one left off.
  </p>
  
  <p>
    The following program fragment (which forms
    the essence of cat) copies data from its standard input to its
    standard output. If an error occurs, it writes a message to the
    standard error.
  </p>
  
  <div class="highlight"><pre><span></span><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;read error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;write error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


         
  <p>
    The important thing to note in the code fragment is that cat doesn’t know whether it
    is reading from a file, console, or a pipe. Similarly cat doesn’t know whether it is
    printing to a console, a file, or whatever. The use of file descriptors and the convention
    that file descriptor 0 is input and file descriptor 1 is output allows a simple implementation
    of cat.
  </p>
  <p>
    The close system call releases a file descriptor, making it free for reuse by a future
    open, pipe, or dup system call (see below). A newly allocated file descriptor is always
    the lowest-numbered unused descriptor of the current process.
  </p>  
  <p>
    File descriptors and fork interact to make I/O redirection easy to implement.
    Fork copies the parent’s file descriptor table along with its memory, so that the child
    starts with exactly the same open files as the parent. The system call exec replaces the
    calling process’s memory but preserves its file table. This behavior allows the shell to
    implement I/O redirection by forking, reopening chosen file descriptors, and then execing
    the new program. Here is a simplified version of the code a shell runs for the
    command cat &lt input.txt:
  </p>

  <div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;cat&quot;</span><span class="p">;</span>
<span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">open</span><span class="p">(</span><span class="s">&quot;input.txt&quot;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
  <span class="n">exec</span><span class="p">(</span><span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


  <p>
    After the child closes file descriptor 0, open
    is guaranteed to use that file descriptor for
    the newly opened <code>input.txt</code>: 0
    will be the smallest available file
    descriptor. Cat then executes with file
    descriptor 0 (standard input) referring to <code>input.txt</code>.
  </p>
  
  <p>
    The code for I/O redirection in the xv6 shell works in exactly
    this way <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8630);"><small>(8630)</small></a></code>. Recall that at this point in the code the
    shell has already forked the child shell and that runcmd will call
    exec to load the new program. Now it should be clear why it is a
    good idea that fork and exec are separate calls. Because if they
    are separate, the shell can fork a child, use open, close, dup in
    the child to change the standard input and output file
    descriptors, and then exec. No changes to the program being
    exec-ed (cat in our example) are required. If fork and exec were
    combined into a single system call, some other (probably more
    complex) scheme would be required for the shell to redirect
    standard input and output, or the program itself would have to
    understand how to redirect I/O.
  </p>
  
  <p>
    Although <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2580);">fork</a></code> copies the file descriptor table,
    each underlying file offset is shared between parent and
    child. Consider this example:
  </p>
  
  <div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;hello &quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">wait</span><span class="p">();</span>
  <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


  
  <p>
    At the end of this fragment, the file attached
    to file descriptor 1 will contain the data hello world. The write in
    the parent (which, thanks to wait, runs only after the child is done)
    picks up where the child’s write left off. This behavior helps produce
    sequential output from sequences of shell commands, like
  </p>
  
 <div class="highlight"><pre><span></span>$ <span class="o">(</span><span class="nb">echo</span> hello<span class="p">;</span> <span class="nb">echo</span> world<span class="o">)</span> &gt; output.txt
</pre></div>


  
  <p>
    The <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6118);">dup</a></code> system call duplicates an existing file
    descriptor, returning a new one that refers to the same underlying
    I/O object. Both file descriptors share an offset, just as the
    file descriptors duplicated by <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2580);">fork</a></code> do. This is
    another way to write hello world into a file:
  </p>
  
  <div class="highlight"><pre><span></span><span class="n">fd</span> <span class="o">=</span> <span class="n">dup</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;hello &quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">&quot;world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</pre></div>


  
  <p>
    Two file descriptors share an offset if they were derived from the
    same original file descriptor by a sequence of <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2580);">fork</a></code>
    and dup calls. Otherwise file descriptors do not
    share offsets, even if they resulted from open calls for the same
    file. Dup allows shells to implement commands like this:
  </p>
    <div class="highlight"><pre><span></span>$ ls existing-file non-existing-file &gt; tmp1 <span class="m">2</span>&gt; <span class="p">&amp;</span><span class="m">1</span>
</pre></div>


  <p>
    The <code>2&gt &1</code> tells the shell to give
    the command a file descriptor 2 that is a duplicate of
    descriptor 1. Both the name of the existing file and the error
    message for the non-existing file will show up in the
    file <code>tmp1</code>. The xv6 shell doesn’t support I/O
    redirection for the error file descriptor, but now you know how
    to implement it.
  </p>
  
  <p>
    File descriptors are a powerful abstraction, because they hide the
    details of what they are connected to: a process writing to file
    descriptor 1 may be writing to a file, to a device like the
    console, or to a pipe.
  </p>


  <h3><p>§ Pipes</p></h3>

  <p>
    A pipe<code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6551);"><small>(6551)</small></a></code> is a small kernel buffer exposed to processes
    as a pair of file descriptors, one for reading and one for
    writing. Writing data to one end of the pipe makes that data
    available for reading from the other end of the pipe. Pipes
    provide a way for processes to communicate.
  </p>

  <p>
    The following example code runs the program wc with standard input
    connected to the read end of a pipe.
  </p>

  <div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;wc&quot;</span><span class="p">;</span>
<span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">dup</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">exec</span><span class="p">(</span><span class="s">&quot;/bin/wc&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;hello world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
  <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>



  <p>
    The program calls pipe, which creates a new pipe and records the
    read and write file descriptors in the array p. After
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2580);">fork</a></code>, both parent and child have file descriptors
    referring to the pipe. The child dups the read end onto file
    descriptor 0, closes the file descriptors in p, and execs wc. When
    wc reads from its standard input, it reads from the pipe. The
    parent closes the read side of the pipe, writes to the pipe, and
    then closes the write side.
  </p>

  <p>
    If no data is available, a on a pipe waits for either data to be
    written or all file descriptors referring to the write end to be
    closed; in the latter case, will return 0, just as if the end of a
    data file had been reached. The fact that blocks until it is
    impossible for new data to arrive is one reason that it's
    important for the child to close the write end of the pipe before
    executing above: if one of file descriptors referred to the write
    end of the pipe, would never see end-of-file.
  </p>
  <p>The xv6 shell implements pipelines such as</p>

  <div class="highlight"><pre><span></span>$ fork sh.c <span class="p">|</span> wc -l
</pre></div>



  <p>
    in a manner similar to the above code <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8650);"><small>(8650)</small></a></code>. The child
    process creates a pipe to connect the left end of the pipeline
    with the right end. Then it calls and for the left end of the
    pipeline and and for the right end, and waits for both to
    finish. The right end of the pipeline may be a command that itself
    includes a pipe (e.g., which itself forks two new child processes
    (one for and one for Thus, the shell may create a tree of
    processes.  The leaves of this tree are commands and the interior
    nodes are processes that wait until the left and right children
    complete.  In principle, you could have the interior nodes run the
    left end of a pipeline, but doing so correctly would complicate
    the implementation.
  </p>

  <p>
    Pipes may seem no more powerful than temporary files: the pipeline
  </p>

  <div class="highlight"><pre><span></span>$ <span class="nb">echo</span> hello world <span class="p">|</span> wc
</pre></div>




  <p>could be implemented without pipes as</p>
  
  <div class="highlight"><pre><span></span>$ <span class="nb">echo</span> hello world &gt; /tmp/xyz<span class="p">;</span> wc &lt; /tmp/xyz
</pre></div>


  
  <p>
    Pipes have at least four advantages over temporary files in this
    situation. First, pipes automatically clean themselves up; with
    the file redirection, a shell would have to be careful to
    remove <code>/tmp/xyz</code> when done. Second, pipes can pass
    arbitrarily long streams of data, while file redirection requires
    enough free space on disk to store all the data. Third, pipes
    allow for parallel execution of pipeline stages, while the file
    approach requires the first program to finish before the second
    starts. Fourth, if you are implementing inter-process
    communication, pipes' blocking reads and writes are more efficient
    than the non-blocking semantics of files.
  </p>

  <h3><p>§ File System</p></h3>

  <p>
    The xv6 file system provides data files, which are
    uninterpreted byte arrays, and directories, which
    contain named references to data files and other
    directories. The directories form a tree, starting
    at a special directory called the root. A path
    like <code>/a/b/c</code> refers to the file or
    directory named <code>c</code> inside the
    directory named <code>b</code> inside the
    directory named <code>a</code> in the root
    directory
    <code>/</code>. Paths that don’t begin with <code>/</code>
    are evaluated relative to the calling process's
    current directory, which can be changed with the
    chdir system call. Both these code fragments open
    the same file (assuming all the directories
    involved exist):
  </p>

  <div class="highlight"><pre><span></span><span class="n">chdir</span><span class="p">(</span><span class="s">&quot;/a&quot;</span><span class="p">);</span>
<span class="n">chdir</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">);</span>
<span class="n">open</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>

<span class="n">open</span><span class="p">(</span><span class="s">&quot;/a/b/c&quot;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
</pre></div>




  <p>
    The first fragment changes the process’s current
    directory to /a/b; the second neither refers to
    nor changes the process’s current directory.
  </p>

  <p>
    There are multiple system calls to create a new file or directory:
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6451);">mkdir</a></code> creates a new directory, open with
    the <b>O_CREATE</b> flag creates a new data file,
    and <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6467);">mknod</a></code> creates a new
    device file. This example illustrates all three:
  </p>

  <div class="highlight"><pre><span></span><span class="n">mkdir</span><span class="p">(</span><span class="s">&quot;/dir&quot;</span><span class="p">);</span>
<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&quot;/dir/file&quot;</span><span class="p">,</span> <span class="n">O_CREATE</span> <span class="o">|</span> <span class="n">O_WRONLY</span><span class="p">);</span>
<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="n">mknod</span><span class="p">(</span><span class="s">&quot;/console&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>



  <p>
    Mknod creates a file in the file system, but the
    file has no contents. Instead, the file’s metadata
    marks it as a device file and records the major
    and minor device numbers (the two arguments to
    mknod), which uniquely identify a kernel
    device. When a process later opens the file, the
    kernel diverts read and write system calls to the
    kernel device implementation instead of passing
    them to the file system.  fstat retrieves
    information about the object a file descriptor
    refers to. It fills in a struct stat, defined in
    stat.h as:
  </p>

  <div class="highlight"><pre><span></span><span class="cp">#define T_DIR 1  </span><span class="c1">// Directory</span>
<span class="cp">#define T_FILE 2 </span><span class="c1">// File</span>
<span class="cp">#define T_DEV 3  </span><span class="c1">// Device</span>

<span class="k">struct</span> <span class="n">stat</span> <span class="p">{</span>
  <span class="kt">short</span> <span class="n">type</span><span class="p">;</span>         <span class="c1">// Type of file</span>
  <span class="kt">int</span> <span class="n">dev</span><span class="p">;</span>            <span class="c1">// File system’s disk device</span>
  <span class="n">uint</span> <span class="n">ino</span><span class="p">;</span>           <span class="c1">// Inode</span>
  <span class="n">number</span> <span class="kt">short</span> <span class="n">nlink</span><span class="p">;</span> <span class="c1">// Number of links to file</span>
  <span class="n">uint</span> <span class="n">size</span><span class="p">;</span>          <span class="c1">// Size of file in bytes</span>
<span class="p">};</span>
</pre></div>



  <p> A file's name is distinct from the file
    itself; the same underlying file, called an
    <i>inode</i> , can have multiple names,
    called 
    .italic-index links .
    The
    <code>link</code>
    system call creates another file system name 
    referring to the same inode as an existing file.
    This fragment creates a new file named both
    <code>a</code>
    and
    <code>b</code> .
  </p>


  <div class="highlight"><pre><span></span><span class="n">open</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">O_CREATE</span> <span class="o">|</span> <span class="n">O_WRONLY</span><span class="p">);</span>
<span class="n">link</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">);</span>
</pre></div>




  <p>
    Reading from or writing to
    <code>a</code> is the same as reading from or
    writing to <code>b</code>. Each inode is
    identified by a unique <i>inode number</i>.  After
    the code sequence above, it is possible to determine
    that <code>a</code> and <code>b</code> refer to the
    same underlying contents by inspecting the result of
    <code>fstat</code>: both will return the same inode number 
    <code>(ino),</code> and the <code>nlink</code> count
    will be set to 2.

  <p>
    The <code>unlink</code> system call removes a name
    from the file system.  The file's inode and the disk
    space holding its content are only freed when the
    file's link count is zero and no file descriptors
    refer to it. Thus adding
  </p>

  <div class="highlight"><pre><span></span><span class="n">unlink</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">);</span>
</pre></div>


  
  <p> to the last code sequence leaves the inode and
    file content accessible as <code>b</code> .
    Furthermore,
  </p>
  
  <div class="highlight"><pre><span></span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&quot;/tmp/xyz&quot;</span><span class="p">,</span> <span class="n">O_CREATE</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">);</span>
<span class="n">unlink</span><span class="p">(</span><span class="s">&quot;/tmp/xyz&quot;</span><span class="p">);</span>
</pre></div>


  
  <p>
    is an idiomatic way to create a temporary inode 
    that will be cleaned up when the process closes 
    <code>fd</code>
    or exits.
  </p>

  <p>
    Shell commands for file system operations are
    implemented as user-level programs such as
    <code>mkdir</code>, <code>ln</code>, <code>rm</code>,
    etc. This design allows anyone to extend the shell
    with new user commands by just adding a new
    user-level program.  In hindsight this plan seems
    obvious, but other systems designed at the time of
    Unix often built such commands into the shell (and
    built the shell into the kernel).
  </p>

  <p>
    One exception is <code>cd</code>, which is built into the shell <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8716);"><small>(8716)</small></a></code> <code>cd</code> must change the current working
    directory of the shell itself.  If <code>cd</code> were run as a
    regular command, then the shell would fork a child process, the
    child process would run <code>cd</code>, and <code>cd</code> would
    change the <i>child's</i> working directory. The parent's (i.e., the
    shell's) working directory would not change.
  </p>

  <br>
  <h3><p>§ Real world</p></h3></h4>

<p>
  Unix's combination of the "standard" file
  descriptors, pipes, and convenient shell syntax for
  operations on them was a major advance in writing
  general-purpose reusable programs.
  The idea sparked a whole culture of "software tools" that was
  responsible for much of Unix's power and popularity,
  and the shell was the first so-called "scripting language."
  The Unix system call interface persists today in systems like
  BSD, Linux, and Mac OS X.
</p>

<p>
  The Unix system call interface has been standardized through the
  Portable Operating System Interface (POSIX) standard. Xv6
  is <i>not</i> POSIX compliant.  It misses system calls (including
  basic ones such as <code>lseek</code>), it implements systems calls
  only partially, etc.  Our main goals for xv6 are simplicity and
  clarity while providing a simple UNIX-like system-call interface.
  Several people have extended xv6 with a few more basic system calls
  and a simple C library so that they can run basic Unix programs.
  Modern kernels, however, provide many more system calls, and many
  more kinds of kernel services, than xv6.  For example, they support
  networking, windowing systems, user-level threads, drivers for many
  devices, and so on.  Modern kernels evolve continuously and rapidly,
  and offer many features beyond POSIX.
</p>

<p>
  For the most part, modern Unix-derived operating
  systems have not followed the early Unix model of
  exposing devices as special files, like the
  <code>console</code> device file discussed above.
  The authors of Unix went on to build Plan 9, which
  applied the "resources are files" concept to modern
  facilities, representing networks, graphics, and
  other resources as files or file trees.
</p>

<p>
  The file system abstraction has been a powerful
  idea. Even so, there are other models for operating
  system interfaces.  Multics, a predecessor of Unix,
  abstracted file storage in a way that made it look
  like memory, producing a very different flavor of
  interface. The complexity of the Multics design had
  a direct influence on the designers of Unix, who
  tried to build something simpler.
</p>

<p>
  This book examines how xv6 implements its Unix-like
  interface, but the ideas and concepts apply to more
  than just Unix. Any operating system must multiplex
  processes onto the underlying hardware, isolate
  processes from each other, and provide mechanisms
  for controlled inter-process communication.  After
  studying xv6, you should be able to look at other,
  more complex operating systems and see the concepts
  underlying xv6 in those systems as well.
</p>
</div>
          <hr>

<!-- ------------------------------------------------------------------ -->
<!-- CHAPTER 1 -->
<!-- <h1><a name="chapter1">CHAPTER 1</a></h1> -->


<h1><a name="chapter1">CHAPTER 1</a></h1> 
<h1>Operating System Organization</h1>
<div>
  <p>
    A key requirement for an operating system is to support several
    activities at once. For example, using the system call interface
    described in chapter 0 a process can start new processes with
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2580);">fork</a></code> The operating system must <i>time-share</i>
    the resources of the computer among these processes. For example,
    even if there are more processes than there are hardware
    processors, the operating system must ensure that all of the
    processes make progress. The operating system must also arrange
    for <i>isolation</i> between the processes. That is, if one
    process has a bug and fails, it shouldn't affect processes that
    don't depend on the failed process. Complete isolation, however,
    is too strong, since it should be possible for processes to
    interact; pipelines are an example. Thus an operating system must
    fulfill three requirements: multiplexing, isolation, and
    interaction.
  </p>

  <p>
    This chapter provides an overview of how operating systems are
    organized to achieve these 3 requirements. It turns out there are
    many ways to do so, but this text focuses on mainstream designs
    centered around a <i>monolithic kernel</i>, which is used by many
    Unix operating systems. This chapter introduces xv6's design by
    tracing the creation of the first process when xv6 starts running.
    In doing so, the text provides a glimpse of the implementation of
    all major abstractions that xv6 provides, how they interact, and
    how the three requirements of multiplexing, isolation, and
    interaction are met. Most of xv6 avoids special-casing the first
    process, and instead reuses <code>that</code> xv6 must provide for
    standard operation. Subsequent chapters will explore each
    abstraction in more detail.
  </p>
  
  <p>
    Xv6 runs on Intel 80386 or later ("x86") processors on a PC platform, and much
    of its low-level functionality (for example, its process implementation) is
    x86-specific. This book assumes the reader has done a bit of machine-level
    programming on some architecture, and will introduce x86-specific ideas as they
    come up. <a onclick="event.stopPropagation()" href="this will be a link">Appendix A</a> briefly outlines the PC platform.
    
    <h3><p>§ Abstracting physical resources</p></h3>
  <p>
    The first question one might ask when encountering an operating system is why
    have it at all?  That is, one could implement the system calls in
    .figref unix:api
    as a library, with which applications link. In this plan,
    each application could even have its own library tailored to its needs.
    Applications could directly interact with hardware resources
    and use those resources in the best way for the application (e.g., to achieve
    high or predictable performance). Some operating systems for
    embedded devices or real-time systems are organized in this way.
  </p>
  <p>              
    The downside of this library approach is that, if there is more than one
    application running, the applications must be well-behaved.
    For example, each application must periodically give up the
    processor so that other applications can run. Such a <i>cooperative</i>
    time-sharing scheme may be OK if all applications trust each
    other and have no bugs. It's more typical for applications
    to not trust each other, and to have bugs, so one often wants
    stronger isolation than a cooperative scheme provides.
  </p>

  <p>
    To achieve strong isolation it's helpful to forbid applications from
    directly accessing sensitive hardware resources, and instead to abstract the
    resources into services. For example, applications interact with a file system
    only through <code>open</code>, <code>read</code>, <code>write</code>, and <code>close</code>
    system calls, instead of read and writing raw disk sectors. 
    This provides the application with the convenience of pathnames, and it allows
    the operating system (as the implementor of the interface) to manage the disk.
  </p>
  
  <p>
    Similarly, Unix transparently switches hardware processors among processes,
    saving and restoring register state as necessary,
    so that applications don't have to be
    aware of time sharing. This transparency allows the operating system to share
    processors even if some applications are in infinite loops.
  </p>
  
  <p>
    As another example, Unix processes use <code>exec</code> to build up their memory image,
    instead of directly interacting with physical memory.
    This allows the operating system to decide where to place a process in
    memory; if memory is tight, the operating system might even store some of
    a process's data on disk. <code>Exec</code> also provides
    users with the convenience of a file system to store executable program images.
  </p>
  <p>
    Many forms of interaction among Unix processes occur via file
    descriptors.  Not only do file descriptors abstract away many
    details (e.g.  where data in a pipe or file is stored), they also
    are defined in a way that simplifies interaction. For example, if
    one application in a pipeline fails, the kernel generates
    end-of-file for the next process in the pipeline.
  </p>
  <p>
    As you can see, the system call interface in .figref unix:api is
    carefully designed to provide both programmer convenience and the
    possibility of strong isolation. The Unix interface is not the
    only way to abstract resources, but it has proven to be a very
    good one.
  </p>
  
  <h3><p>§ User mode, kernel mode, and system calls</p></h3>
  
  <p>
    Strong isolation requires a hard boundary between applications and
    the operating system. If the application makes a mistake, we don't
    want the operating system to fail or other applications to
    fail. Instead, the operating system should be able to clean up the
    failed application and continue running other applications.  To
    achieve strong isolation, the operating system must arrange that
    applications cannot modify (or even read) the operating system's
    data structures and instructions and that applications cannot
    access other process's memory.
  </p>
  <p>
    Processors provide hardware support for strong isolation.  For
    example, the x86 processor, like many other processors, has two
    modes in which the processor can execute instructions: <i>kernel
    mode</i> and <i>user mode</i>.  In kernel mode the processor is
    allowed to execute <i>privileged instructions</i>.  For example,
    reading and writing the disk (or any other I/O device) involves
    privileged instructions. If an application in user mode attempts
    to execute a privileged instruction, then the processor doesn't
    execute the instruction, but switches to kernel mode so that the
    software in kernel mode can clean up the application, because it
    did something it shouldn't be doing. .figref unix:os Figure 0-1 in
    in Chapter 0 illustrates this organization. An application can
    execute only user-mode instructions (e.g., adding numbers, etc.)
    and is said to be running in <i>"user space"</i>, while the
    software in kernel mode can also execute privileged instructions
    and is said to be running in <i>"kernel space"</i>.  The software
    running in kernel space (or in kernel mode) is called
    the <i>"kernel"</i>.
  </p>
  <p>
    An application that wants to read or write a file on disk must
    transition to the kernel to do so, because the application itself
    can not execute I/O instructions. Processors provide a special
    instruction that switches the processor from user mode to kernel
    mode and enters the kernel at an entry point specified by the
    kernel. (The x86 processor provides the <code>int</code>
    instruction for this purpose.)  Once the processor has switched to
    kernel mode, the kernel can then validate the arguments of the
    system call, decide whether the application is allowed to perform
    the requested operation, and then deny it or execute it. It is
    important that the kernel sets the entry point for transitions to
    kernel mode; if the application could decide the kernel entry
    point, a malicious application could enter the kernel at a point
    where the validation of arguments etc. is skipped.
    
    <h3><p>§ Kernel organization</p></h3>
  <p>
    A key design question is what part of the operating
    system should run in kernel mode. 
    One possibility is that the entire operating system resides
    in the kernel, so that the implementations of all system calls
    run in kernel mode. This organization is called a <i>monolithic kernel</i>.
  </p>
  <p>
    In this organization the entire operating system runs with full hardware
    privilege. This organization is convenient because the OS designer doesn't have
    to decide which part of the operating system doesn't need full hardware
    privilege. Furthermore, it easy for different parts of the operating system to
    cooperate. For example, an operating system might have a buffer cache that can
    be shared both by the file system and the virtual memory system.
  </p>
  <p>
    A downside of the monolithic organization is that the interfaces between
    different parts of the operating system are often complex (as we will see in the
    rest of this text), and therefore it is easy for an operating system developer
    to make a mistake. In a monolithic kernel, a mistake is fatal, because an error
    in kernel mode will often result in the kernel to fail. If the kernel fails,
    the computer stops working, and thus all applications fail too. The computer
    must reboot to start again.
  </p>
  
  <p>
    To reduce the risk of mistakes in the kernel, OS designers can
    minimize the amount of operating system code that runs in kernel
    mode, and execute the bulk of the operating system in user
    mode. This kernel organization is called a <i>microkernel</i>.
  </p>

  
    <br/>
    <img src="figs/fig1-1.jpg" alt="figure 1-1" class="img-thumbnail">
    <br>
    <br>
    <center>
      <b>Figure 1-1.</b>
      <small class="text-muted">A microkernel with a file system server</small>
    </center>
    <br><br>
    

  <p>
    Figure 1-1 illustrates this microkernel design. In the figure, the
    file system runs as a user-level process. OS services running as
    processes are called servers. To allow applications to interact
    with the file server, the kernel provides an inter-process
    communication mechanism to send messages from one user-mode
    process to another. For example, if an application like the shell
    wants to read or write a file, it sends a message to the file
    server and waits for a response.
  </p>
  
  <p>
    In a microkernel, the kernel interface consists of a few low-level
    functions for starting applications, sending messages,
    accessing device hardware, etc. This organization allows the kernel to be 
    relatively simple, as most of the operating system
    resides in user-level servers.
  </p>

  <p>
    Xv6 is implemented as a monolithic kernel, following most Unix
    operating systems.  Thus, in xv6, the kernel interface corresponds
    to the operating system interface, and the kernel implements the
    complete operating system. Since xv6 doesn't provide many
    services, its kernel is smaller than some microkernels.
  </p>
  
  <h3><p>§ Process overview</p></h3>

  <p>
    The unit of isolation in xv6 (as in other Unix operating systems)
    is a <i>"process"</i>. The process abstraction prevents one
    process from wrecking or spying on another process's memory, CPU,
    file descriptors, etc. It also prevents a process from wrecking
    the kernel itself, so that a process can't subvert the kernel's
    isolation mechanisms. The kernel must implement the process
    abstraction with care because a buggy or malicious application may
    trick the kernel or hardware in doing something bad (e.g.,
    circumventing enforced isolation). The mechanisms used by the
    kernel to implement processes include the user/kernel mode flag,
    address spaces, and time-slicing of threads.
  </p>

  <p>
    To help enforce isolation, the process abstraction provides the
    illusion to a program that it has its own private machine. A process provides
    a program with what appears to be a private memory system, or
    <i>"address space"</i>, which other processes cannot read or write.
    A process also provides the program with what appears to be its own
    CPU to execute the program's instructions.
  </p>

  <p>
    Xv6 uses page tables (which are implemented by hardware) to give
    each process its own address space. The x86 page table translates
    (or "maps") a <i>"virtual address"</i>(the address that an x86
    instruction manipulates) to a <i>"physical address"</i> (an
    address that the processor chip sends to main memory).
  </p>

  <br>
  <img src="figs/fig1-2.jpg" alt="figure 1" class="img-thumbnail">
  <center>
    Figure 1-2. <small class="text-muted">Layout of a virtual address space</small>
  </center>
  <br>

  <p>
    Xv6 maintains a separate page table for each process that defines
    that process's address space. As illustrated in .figref as , an
    address space includes the process's <i>"user memory"</i> starting
    at virtual address zero. Instructions come first, followed by
    global variables, then the stack, and finally a "heap" area (for
    malloc) that the process can expand as needed.
  </p>

  <p>
    Each process's address space maps the kernel's instructions and
    data as well as the user program's memory.  When a process invokes
    a system call, the system call executes in the kernel mappings of
    the process's address space.  This arrangement exists so that the
    kernel's system call code can directly refer to user memory.  In
    order to leave plenty of room for user memory, xv6's address
    spaces map the kernel at high addresses, starting at
    <code>0x80100000 .</code>
  </p>
  
  <p>
    The xv6 kernel maintains many pieces of state for each process,
    which it gathers into a <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2337);">struct proc</a></code>. A
    process's most important pieces of kernel state are its page
    table, its kernel stack, and its run state.  We'll use the
    notation <code>p->xxx</code> to refer to elements of the
    <code>proc</code> structure.
  </p>
  
  <p>
    Each process has a thread of execution (or <i>thread</i> for
    short) that executes the process's instructions. A thread can be
    suspended and later resumed. To switch transparently between
    processes, the kernel suspends the currently running thread and
    resumes another process's thread. Much of the state of a thread
    (local variables, function call return addresses) is stored on the
    thread's stacks. Each process has two stacks: a user stack and a
    kernel stack (<code>p->kstack</code>). When the process is
    executing user instructions, only its user stack is in use, and
    its kernel stack is empty. When the process enters the kernel (for
    a system call or interrupt), the kernel code executes on the
    process's kernel stack; while a process is in the kernel, its user
    stack still contains saved data, but isn't actively used. A
    process's thread alternates between actively using its user stack
    and its kernel stack. The kernel stack is separate (and protected
    from user code) so that the kernel can execute even if a process
    has wrecked its user stack.
  </p>

  <p>
    When a process makes a system call, the processor switches to the
    kernel stack, raises the hardware privilege level, and starts
    executing the kernel instructions that implement the system call.
    When the system call completes, the kernel returns to user space:
    the hardware lowers its privilege level, switches back to the user
    stack, and resumes executing user instructions just after the
    system call instruction. A process's thread can "block" in the
    kernel to wait for I/O, and resume where it left off when the I/O
    has finished.
  </p>
  
  <p>
    <code>p->state</code> indicates whether the process is allocated, ready
    to run, running, waiting for I/O, or exiting.
  </p>
  
  <p>
    <code>p->pgdir</code> holds the process's page table, in the
    format that the x86 hardware expects.  xv6 causes the paging
    hardware to use a process's memory <code>p->pgdir</code> when
    executing that process. A process's page table also serves as the
    record of the addresses of the physical pages allocated to store
    the process's memory.
  </p>
  
  <h3><p>§ Code: the first address space</p></h3>

  <p>
    To make the xv6 organization more concrete, we'll look how the
    kernel creates the first address space (for itself), how the
    kernel creates and starts the first process, and how that process
    performs the first system call. By tracing these operations we see
    in detail how xv6 provides strong isolation for processes.  The
    first step in providing strong isolation is setting up the kernel
    to run in its own address space.
  </p>
  
  <p>
    When a PC powers on, it initializes itself and then loads a
    <i>boot loader</i> from disk into memory and executes it. <a onclick="event.stopPropagation()" href="this will be a link">Appendix B</a>
    explains the details. Xv6's boot loader loads the xv6
    kernel from disk and executes it starting at <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1044);">entry</a></code>.
    The x86 paging hardware is not enabled when the kernel starts;
    virtual addresses map directly to physical addresses.
  </p>
  
  <p>
    The boot loader loads the xv6 kernel into memory at physical address
    <code>0x100000</code>.
    The reason it doesn't load the kernel at
    <code>0x80100000</code> ,
    where the kernel expects to find its instructions and data,
    is that there may not be any physical memory at such
    a high address on a small machine.
    The reason it places the kernel at
    <code>0x100000</code>
    rather than
    <code>0x0</code>
    is because the address range
    <code>0xa0000:0x100000</code>
    contains I/O devices.
    .figure astmp
  </p>
  
  <p>
    To allow the rest of the kernel to run,
    <code>entry</code>
    sets up a page table that maps virtual addresses starting at
    <code>0x80000000</code>
    (called <code><a href="javascript:gotoLine(207);">KERNBASE</a></code>)
    to physical addresses starting at
    <code>0x0</code>
    (see .figref as ).
    Setting up two ranges of virtual addresses that map to the same physical memory
    range is a common use of page tables, and we will see more examples like this
    one.
  </p>

  <p>
    The entry page table is defined in main.c
    .line 'main.c:/^pde_t.entrypgdir.*=/' .
    We look at the details of page tables in Chapter 2,
    but the short story is that entry 0 maps virtual addresses
    <code>0:0x400000</code> to physical
    addresses <code>0:0x400000</code>.  This mapping is required as
    long as <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1044);">entry</a></code> is executing at low addresses, but
    will eventually be removed.
  </p>
  
  <p>
    Entry 512 maps virtual
    addresses <code>KERNBASE:KERNBASE+0x400000</code> to physical
    addresses <code>0:0x400000</code>. This entry will be used by the
    kernel <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1044);">entry</a></code> has finished; it maps the high
    virtual addresses at which the kernel expects to find its
    instructions and data to the low physical addresses where the boot
    loader loaded them. This mapping restricts the kernel instructions
    and data to 4 Mbytes.
  </p>

  <p>
    Returning to
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1044);">entry</a></code> it loads the physical address of
    <code>entrypgdir</code> into control register <a class="popoverOption" data-content="%cr3 is used when PG is set. CR3 enables the processor to locate
    the page table directory for the current task . Refer to Chapter 5 for
    a description of page tables and page translation." rel="popover"><code>%cr3</code></a>. The
    value in <a class="popoverOption" data-content="%cr3 is used when PG is set. CR3 enables the processor to locate
    the page table directory for the current task . Refer to Chapter 5 for
    a description of page tables and page translation." rel="popover"><code>%cr3</code></a> must be a physical address. It wouldn't
    make sense for <a class="popoverOption" data-content="%cr3 is used when PG is set. CR3 enables the processor to locate
    the page table directory for the current task . Refer to Chapter 5 for
    a description of page tables and page translation." rel="popover"><code>%cr3</code></a> to hold the virtual address of
    <code>entrypgdir</code>, because the paging hardware doesn't know
    how to translate virtual addresses yet; it doesn't have a page
    table yet. The symbol <code>entrypgdir</code>, refers to an
    address in high memory, and the macro <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(213);">V2P_WO</a></code>
    subtracts <code>KERNBASE</code> in order to find the physical
    address.  To enable the paging hardware, xv6 sets the flag
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(709);">CR0_PG</a></code> in the control register <a class="popoverOption" data-content="%cr0 contains system control flags, which control or indicate
    conditions that apply to the system as a whole, not to an individual
    task." rel="popover"><code>%cr0</code></a>
  </p>

  <p>
    The processor is still executing instructions at low addresses
    after paging is enabled, which works since <code>entrypgdir</code>
    maps low addresses.  If xv6 had omitted entry 0
    from <code>entrypgdir</code>, the computer would have crashed when
    trying to execute the instruction after the one that enabled
    paging.
  </p>

  <p>
    Now <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1044);">entry</a></code> needs to transfer to the kernel's C
    code, and run it in high memory.  First it makes the stack
    pointer, <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a>, point to memory to be used as a stack
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1058);"><small>(1058)</small></a></code>.  All symbols have high addresses,
    including <code>stack</code>, so the stack will still be valid
    even when the low mappings are removed.  Finally
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1044);">entry</a></code> jumps to <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1217);">main</a></code> which is also a
    high address. The indirect jump is needed because the assembler
    would otherwise generate a PC-relative direct jump, which would
    execute the low-memory version
    of <code>main</code>. <code>Main</code> cannot return, since the
    there's no return PC on the stack.  Now the kernel is running in
    high addresses in the function <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1217);">main</a></code>.
  </p>
  
  <h3><p>§ Code: creating the first process</p></h3>
  
  <p>
    Now we'll look at how the kernel
    creates user-level processes and ensures that they are strongly isolated.
  </p>
  
  <p>
    After
    <a href="javascript:gotoLine(1217);"><code class="">main</code></a> 
    initializes several devices and subsystems, 
    it creates the first process by calling
    <a href="javascript:gotoLine(2520);"><code class="">userinit</code></a>, 
    <code>Userinit</code>'s
    first action is to call
    <a href="javascript:gotoLine(2473);"><code class="">allocproc</code></a>, 
    The job of
    is to allocate a slot
    <a href="javascript:gotoLine(2337);"><code>struct proc</code></a>
    in the process table and
    to initialize the parts of the process's state
    required for its kernel thread to execute.
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2473);">allocproc</a></code> is called for each new process, while
    <a href="javascript:gotoLine(2520);"><code>userinit</code></a> 
    is called only for the very first process.
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2473);">allocproc</a></code>
    scans the 
    <code>proc</code>
    table for a slot with state
    <a href="javascript:gotoLine(2480);"><code>UNUSED</code></a> 
    When it finds an unused slot, 
    <a href="javascript:gotoLine(2473);"><code class="">allocproc</code></a>
    sets the state to
    <code>EMBRYO</code>
    to mark it as used and
    gives the process a unique
    <a href="javascript:gotoLines(2469, 2489);"><code class="">pid</code></a>, 
    
    Next, it tries to allocate a kernel stack for the
    process's kernel thread. If the memory allocation fails, 
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2473);">allocproc</a></code>
    changes the state back to
    <code>UNUSED</code>
    and returns zero to signal failure.
    
    <a name="fig1-4"></a>
    <br/>
    <br/>
    <img src="figs/fig1-4.jpg" alt="figure 1-4" class="img-thumbnail">
    
    <center><i>figure 1-4. A new kernel stack.</i></center>
    <br/>
    
  <p>
    Now <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2473);">allocproc</a></code> must set up the new process's kernel stack.
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2473);">allocproc</a></code>
    is written so that it can be used by 
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2580);">fork</a></code>
    as well
    as when creating the first process.
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2473);">allocproc</a></code> sets up the new process with a
    specially prepared kernel stack and set of kernel
    registers that cause it to "return" to user space when
    it first runs. The layout of the prepared kernel stack
    will be as shown in <b>figure 1-4</b>. <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2473);">allocproc</a></code>
    does part of this work by setting up return program
    counter values that will cause the new process's kernel
    thread to first execute in <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2853);">forkret</a></code> and then
    in <a href="javascript:gotoLines(2507,2512);"><code>trapret.</code></a>
    
    The kernel thread will start executing with register contents copied from
    <code>p->context.</code> Thus setting <code>p->context->eip</code> 
    to <code>forkret</code> will cause the kernel thread to execute at
    the start of <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2853);">forkret</a></code>.
    
    This function will return to whatever address is at the bottom of
    the stack. The context switch code <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3058);"><small>(3058)</small></a></code> sets the stack
    pointer to point just beyond the end of <code>p->context.</code>
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2473);">allocproc</a></code> places <code>p->context</code> on the stack, and puts a pointer to
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3324);">trapret</a></code> just above it; that is where <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2853);">forkret</a></code> 
    will return. <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3324);">trapret</a></code> restores user registers
    from values stored at the top of the kernel stack and jumps
    into the <a href="javascript:gotoLine(3324);">process</a>
    This setup is the same for ordinary <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2580);">fork</a></code>
    and for creating the first process, though in
    the latter case the process will start executing at
    user-space location zero rather than at a return from
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2580);">fork</a></code>.
  </p>

  <p>
    As we will see in Chapter 3, the way that control transfers from
    user software to the kernel is via an interrupt mechanism, which
    is used by system calls, interrupts, and exceptions. Whenever
    control transfers into the kernel while a process is running, the
    hardware and xv6 trap entry code save user registers on the
    process's kernel stack. <code>userinit</code> writes values at the
    top of the new stack that look just like those that would be there
    if the process had entered the kernel via an <code><a onclick="event.stopPropagation()" href="javascript:gotoLines(2533, 2540);">interrupt</a></code> so that the ordinary code for returning
    from the kernel back to the process's user code will work. These
    values are a <code>struct</code> <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(602);">trapframe</a></code>
    which stores the user registers. Now the new process's kernel stack is
    completely prepared as shown in  
    <a class="popoverOption" href="#fig1-4" data-content="<img src='figs/fig1-4.jpg' alt='figure 1-4'>" 
    rel="popover" data-placement="bottom" data-original-title="Figure 1-4">Figure 1-4</a>
  </p>

  <p>
    The first process is going to execute a small program
    (<a href="javascript:gotoLine(8400);">initcode.S</a>).
    The process needs physical memory in which to store this
    program, the program needs to be copied to that memory,
    and the process needs a page table that maps user-space addresses to
    that memory.
  </p>
  <p>
    <code>userinit</code> calls <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1818);">setupkvm</a></code> to create a
    page table for the process with (at first) mappings only for
    memory that the kernel uses.  We will study this function in
    detail in Chapter 2, but at a high level  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1818);">setupkvm</a></code>
    and <code>userinit </code> create an address space as shown in

    <a class="popoverOption" href="#fig1-2" data-content="<img src='figs/fig1-2.jpg' alt='figure 1-2'>"
       rel="popover" data-placement="bottom" data-original-title="Figure 1-2">Figure 1-2</a>.
  </p>

  <p>
    The initial contents of the first process's user-space memory are
    the compiled form of <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8400);">initcode.S</a></code> as part of the kernel build process, the linker
    embeds that binary in the kernel and defines two special symbols,
    <code>_binary_initcode_start</code> and <code>_binary_initcode_size</code>,
    indicating the location and size of the binary. <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2520);">userinit</a></code>
    copies that binary into the new process's memory by calling
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1886);">inituvm</a></code>, which allocates one page of physical memory,
    maps virtual address zero to that memory, and copies the binary to that page.
  </p>
  <p>
    Then <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2520);">userinit</a></code> sets up the <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(602);">trapframe</a></code>
    with the initial user mode state: the
    <a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a> register contains a segment selector for the
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(716);">SEG_UCODE</a></code> segment running at privilege level
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(761);">DPL_USER</a></code> (i.e., user mode rather than kernel mode),
    and similarly
    <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%ds</code></a>, <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%es</code></a>, and <a class="popoverOption" data-content="The stack segment (SS) register. Stacks are implemented in
    memory. A system may have a number of stacks that is limited only by
    the maximum number of segments. A stack may be up to 4 gigabytes long,
    the maximum length of a segment. One stack is directly addressable at
    a -- one located by SS. This is the current stack, often referred to
    simply as 'the' stack. SS is used automatically by the processor for
    all stack operations." rel="popover"><code>%ss</code></a> use <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(717);">SEG_UDATA</a></code> with privilege
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(761);">DPL_USER</a></code>. The <a class="popoverOption" data-content="The status flags of the EFLAGS register allow the results of one
    instruction to influence later instructions. The arithmetic
    instructions use OF, SF, ZF, AF, PF, and CF. The SCAS (Scan String),
    CMPS (Compare String), and LOOP instructions use ZF to signal that
    their operations are complete. There are instructions to set, clear,
    and complement CF before execution of an arithmetic instruction. Refer
    to Appendix C for definition of each status flag." rel="popover"><code>%eflags</code></a> <code>FL_IF</code> bit is set to allow hardware interrupts;
    we will reexamine this in 3.

  </p><p>
    The stack pointer <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a>
    is set to the process's largest valid virtual address,
    <code>p->sz.</code> 
    The instruction pointer is set to the entry point
    for the initcode, address 0.

  </p><p>
    The function <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2520);">userinit</a></code>
    sets <code>p->name</code> to <code>"initcode"</code> 
    mainly for debugging.
    Setting
    <code>p->cwd</code> 
    sets the process's current working directory;
    we will examine
    <code>namei</code> 
    in detail in Chapter \*[CH:FS].
  </p><p>
    Once the process is initialized,
    <code>userinit</code> 
    marks it available for scheduling by setting 
    <code>p->state</code> 
    to
    <code>RUNNABLE.</code>

    
    .\"
    .section "Code: Running the first process"
    .\"
    
    Now that the first process's state is prepared, it is time
    to run it. After <code>main</code> calls
    <code>userinit,</code> 
    <code>mpmain</code> 
    calls
    <code>scheduler</code> 
    to start running processes
    .line main.c:/scheduler/ .
    <code>Scheduler</code> 
    .line proc.c:/^scheduler/
    looks for a process with
    <code>p->state</code> 
    set to
    <code>RUNNABLE ,</code> 
    and there's only one:
    <code>initproc .</code> 
    It sets the per-cpu variable
    <code>proc</code> 
    to the process it found and calls
    <code>switchuvm</code> 
    to tell the hardware to start using the target
    process's page table
    .line vm.c:/lcr3.*V2P.p..pgdir/ .
    Changing page tables while executing in the kernel
    works because 
    <code>setupkvm</code> 
    causes all processes' page tables to have identical
    mappings for kernel code and data.
    <code>switchuvm</code> 
    also sets up a task state segment
    <code>SEG_TSS</code> 
    that instructs the hardware to
    execute system calls and interrupts
    on the process's kernel stack.
    We will re-examine the task state segment in Chapter \*[CH:TRAP].

  </p><p>
    <code>scheduler</code> 
    now sets
    <code>p->state</code> 
    to
    <code>RUNNING</code> 
    and calls
    <code>swtch</code> 
    .line swtch.S:/^swtch/ 
    to perform a context switch to the target process's kernel thread.
    <code>swtch </code> 
    first saves the current registers.
    The current context is not a process but rather a special
    per-cpu scheduler context, so
    <code>scheduler</code> 
    tells
    <code>swtch</code> 
    to save the current hardware registers in per-cpu storage
    <code>cpu->scheduler ) (</code> 
    rather than in any process's kernel thread context.
    <code>swtch</code> 
    then loads the saved registers
    of the target kernel thread
    <code>p->context ) (</code> 
    into the x86 hardware registers,
    including the stack pointer and instruction pointer.
    We'll examine
    <code>swtch</code> 
    in more detail in Chapter \*[CH:SCHED].
    The final
    <code>ret</code> 
    instruction 
    .line swtch.S:/ret$/
    pops the target process's
    <a class="popoverOption" data-content="intruction pointer register." rel="popover"><code>%eip</code></a>
    from the stack, finishing the context switch.
    Now the processor is running on the kernel stack of process
    <code>p .</code> 
  </p><p>
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2473);">allocproc</a></code> 
    had previously set
    <code>initproc 's</code> 
    <code>p->context->eip</code> 
    to
    <code>forkret ,</code> 
    so the 
    <code>ret</code> 
    starts executing
    <code>forkret .</code> 
    On the first invocation (that is this one),
    <code>forkret</code> 
    .line proc.c:/^forkret/
    runs initialization functions that cannot be run from 
    <code>main </code> 
    because they must be run in the context of a regular process with its own
    kernel stack. 
    Then, 
    <code>forkret </code> 
    returns.
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2473);">allocproc</a></code> 
    arranged that the top word on the stack after
    <code>p->context</code> 
    is popped off
    would be 
    <code>trapret ,</code> 
    so now 
    <code>trapret</code> 
    begins executing,
    with 
    <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a>
    set to
    <code>p->tf .</code> 
    <code>Trapret</code> 
    .line trapasm.S:/^trapret/ 
    uses pop instructions to restore registers from
    the trap frame
    .line x86.h:/^struct.trapframe/
    just as 
    <code>swtch</code> 
    did with the kernel context:
    <code>popal</code> 
    restores the general registers,
    then the
    <code>popl </code> 
    instructions restore
    <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%gs</code></a>,
   <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%fs</code></a> ,
   <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%es</code></a> ,
    and
   <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%ds</code></a> .
    The 
    <code>addl</code> 
    skips over the two fields
    <code>trapno</code> 
    and
    <code>errcode .</code> 
    Finally, the
    <code>iret</code> 
    instruction pops 
   <a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a> ,
    <a class="popoverOption" data-content="intruction pointer register." rel="popover"><code>%eip</code></a> ,
    fl<a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%ags</code></a> ,
    <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a> ,
    and
   <a class="popoverOption" data-content="The stack segment (SS) register. Stacks are implemented in
    memory. A system may have a number of stacks that is limited only by
    the maximum number of segments. A stack may be up to 4 gigabytes long,
    the maximum length of a segment. One stack is directly addressable at
    a -- one located by SS. This is the current stack, often referred to
    simply as 'the' stack. SS is used automatically by the processor for
    all stack operations." rel="popover"><code>%ss</code></a>
    from the stack.
    The contents of the trap frame
    have been transferred to the CPU state,
    so the processor continues at the
    <a class="popoverOption" data-content="intruction pointer register." rel="popover"><code>%eip</code></a>
    specified in the trap frame.
    <code>initproc</code>,
    that means virtual address zero,
    the first instruction of
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8400);">initcode.S</a></code>.
  </p>
  <p>
    At this point, <a class="popoverOption" data-content="intruction pointer register." rel="popover"><code>%eip</code></a> holds zero and <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a>
    holds 4096. These are virtual addresses in the process's address
    space. The processor's paging hardware translates them into
    physical addresses. <code>allocuvm</code> has set up the process's
    page table so that virtual address zero refers to the physical
    memory allocated for this process, and set a flag
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(803);">PTE_U</a></code> that tells the paging hardware to allow user
    code to access that memory.  The fact that
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2520);">userinit</a></code> set up the low bits of
    <a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a> to run the process's user code at CPL=3 means
    that the user code can only use pages with <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(803);">PTE_U</a></code>
    set, and cannot modify sensitive hardware registers such as
    <a class="popoverOption" data-content="%cr3 is used when PG is set. CR3 enables the processor to locate
    the page table directory for the current task . Refer to Chapter 5 for
    a description of page tables and page translation." rel="popover"><code>%cr3</code></a>. So the process is constrained to using only its own
    memory.
  </p>
    
  <h3><p>§ The first system call: exec</p></h3>
  
  <p>
    Now that we have seen how the kernel provides strong isolation for
    processes, let's look at how a user-level process re-enters the
    kernel to ask for services that it cannot perform itself.
  </p>
  <p>
    The first action of <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8400);">initcode.S</a></code> is to invoke  the
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> system call. As we saw in Chapter 0], 
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> replaces the memory and registers of the
    current process with a new program, but it leaves the
    file descriptors, process id, and parent process unchanged.
  </p>
  <p>
    
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8400);">initcode.S</a></code>.
    line initcode.S:/^start/
    begins by pushing three values
    on the stack-\c
    <code>$argv ,</code> 
    <code>$init ,</code> 
    and
    <code>$0 -\c</code> 
    and then sets
    <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%eax</code></a>
    to
    <code>SYS_exec</code> 
    and executes
    <code>int</code> 
    <code>T_SYSCALL :</code> 
    it is asking the kernel to run the
    <code>exec</code> 
    system call.
    If all goes well,
    <code>exec</code> 
    never returns: it starts running the program 
    named by
    <code>$init ,</code> 
    which is a pointer to
    the NUL-terminated string
    <code>"/init"</code> 
    .line initcode.S:/init.0/,/init.0/ .
    The other argument is the
    <code>argv</code> 
    array of command-line arguments; the zero at the
    end of the array marks its end.
    If the
    <code>exec</code> 
    fails and does return,
    initcode
    loops calling the
    <code>exit</code> 
    system call, which definitely
    should not return
    .line initcode.S:/for.*exit/,/jmp.exit/ .
  </p><p>
    This code manually crafts the first system call to look like
    an ordinary system call, which we will see in Chapter \*[CH:TRAP]. As
    before, this setup avoids special-casing the first process (in this
    case, its first system call), and instead reuses code that xv6 must
    provide for standard operation.
    
  </p>
  <p>

    Chapter 2 will cover the implementation
    of <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> in detail, but at a high level it replaces
    <code>initcode</code> with the <code>/init</code> binary, loaded
    out of the file system. Now <code>initcode</code>
    .line initcode.S:1
    is done, and the process will run <code>/init</code>
    instead. <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8510);">init</a></code> creates a new
    console device file if needed and then opens it as file
    descriptors 0, 1, and 2. Then it loops, starting a console shell,
    handles orphaned zombies until the shell exits, and repeats. The system is up.

    <h3><p>§ Real world</p></h3>
    
  </p>
  <p>
    In the real world, one can find both monolithic kernels and
    microkernels. Many Unix kernels are monolithic. For example, Linux
    has a monolithic kernel, although some OS functions run as
    user-level servers (e.g., the windowing system). Kernels such as
    L4, Minix, QNX are organized as a microkernel with servers, and
    have seen wide deployment in embedded settings.
    
  </p><p>
    Most operating systems have adopted the process
    concept, and most processes look similar to xv6's.
    A real operating system would find free
    <code>proc</code> 
    structures with an explicit free list
    in constant time instead of the linear-time search in
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2473);">allocproc</a></code>;
    xv6 uses the linear scan
    (the first of many) for simplicity.
  </p>

  <h3><p>§ Exercises</p></h3>
  
  <p>
    1. Set a breakpoint at swtch. Single step with
    gdb's <code>stepi</code> through the ret to
    <code>forkret</code>, then use gdb's <code>finish</code> to
    proceed to <code>trapret</code>, then <code>stepi</code> until you
    get to <code>initcode</code> at virtual address zero.
  </p>

  <p>
    2. <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(207);">KERNBASE</a></code> limits the amount of memory a single
    process can use, which might be irritating on a machine with a
    full 4 GB of RAM. Would raising <code>KERNBASE</code> allow a
    process to use more memory?
  </p>
    
    
</div> <!-- end chapter1 -->
          


<hr>
<h1><a name="chapter2">CHAPTER 2</a></h1>

<h1>Page tables</h1>

<div>
<p>
Page tables are the mechanism through which the operating system
controls what memory addresses mean.  They allow xv6 to multiplex the
address spaces of different processes onto a single physical memory,
and to protect the memories of different processes.  The level of
indirection provided by page tables allows many neat tricks.  xv6 uses
page tables primarily to multiplex address spaces and to protect
memory.  It also uses a few simple page-table tricks: mapping the same
memory (the kernel) in several address spaces, mapping the same memory
more than once in one address space (each user page is also mapped
into the kernel's physical view of memory), and guarding a user stack
with an unmapped page.  The rest of this chapter explains the page
tables that the x86 hardware provides and how xv6 uses them.  Compared
to a real-world operating system, xv6's design is restrictive, but it
does illustrate the key ideas.
</p>

<h3><p>§ Paging hardware</p></h3>

<p>
  As a reminder, x86 instructions (both user and kernel) manipulate
  virtual addresses.  The machine's RAM, or physical memory, is indexed
  with physical addresses.
</p>

<p>
  The x86 page table hardware connects these two kinds of addresses,
  by mapping each virtual address to a physical address.
</p>

<p>
  
  
  
  
  
  
  
  
  
  
  



  
  An x86 page table is logically an array of 2^20 (1,048,576) 
  <i>page table entries (PTEs)</i>. Each PTE contains a     
  20-bit physical page number (PPN) and some flags. The paging  
  hardware translates a virtual address by using its top 20 bits to  
  index into the page table to find a PTE, and replacing  
  the address's top 20 bits with the PPN in the PTE.  The  
  paging hardware copies the low 12 bits unchanged from the virtual to 
  the translated physical address.  Thus a page table gives the 
  operating system control over virtual-to-physical address 
  translations at the granularity of aligned chunks of 4096 (2^12) 
  bytes. Such a chunk is called a <i>page</i>. 
</p>

<p>
  As shown in  
    <a class="popoverOption" href="#fig2-1" data-content="<img src='figs/fig2-1.jpg' alt='figure 2-1'>" 
    rel="popover" data-placement="bottom" data-original-title="Figure 2-1">Figure 2-1</a>, the actual translation
  happens in two steps.  A page table is stored in physical memory as
  a two-level tree.  The root of the tree is a 4096-byte <i>page
  directory</i> that contains 1024 PTE-like references
  to <i>page table pages</i>. Each page table page is an array of 1024
  32-bit PTEs.  The paging hardware uses the top 10 bits of
  a virtual address to select a page directory entry.  If the page
  directory entry is present, the paging hardware uses the next 10
  bits of the virtual address to select a PTE from the page
  table page that the page directory entry refers to.  If either the
  page directory entry or the PTE is not present, the
  paging hardware raises a fault.  This two-level structure allows a
  page table to omit entire page table pages in the common case in
  which large ranges of virtual addresses have no mappings.
</p>

  
    <br/>
    <img src="figs/fig2-1.jpg" alt="figure 2-1" class="img-thumbnail">
    <br>
    <br>
    <center>
      <b>Figure 2-1.</b>
      <small class="text-muted">x86 page table hardware</small>
    </center>
    <br><br>
    

<p>
  Each PTE contains flag bits that tell the paging hardware
  how the associated virtual address is allowed to be used.
  <code>PTE_P</code> indicates whether the PTE is present: if it is
  not set, a reference to the page causes a fault (i.e. is not
  allowed). <code>PTE_W</code> controls whether instructions are
  allowed to issue writes to the page; if not set, only reads and
  instruction fetches are allowed.
  <code>PTE_U</code> controls whether user programs are allowed to use
  the page; if clear, only the kernel is allowed to use the page.
   
    <a class="popoverOption" href="#fig2-1" data-content="<img src='figs/fig2-1.jpg' alt='figure 2-1'>" 
    rel="popover" data-placement="bottom" data-original-title="Figure 2-1">Figure 2-1</a> shows how it all works.  The flags and all other
  page hardware related structures are defined in <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(700);">mmu.h</a></code>.
</p>
  
<p>  
A few notes about terms.  Physical memory refers to storage cells in
DRAM.  A byte of physical memory has an address, called a physical
address.  Instructions use only virtual addresses, which the paging
hardware translates to physical addresses, and then sends to the DRAM
hardware to read or write storage.  At this level of discussion there
is no such thing as virtual memory, only virtual addresses.
</p>


    <br/>
    <img src="figs/fig2-2.jpg" alt="figure 2-2" class="img-thumbnail">
    <br>
    <br>
    <center>
      <b>Figure 2-2.</b>
      <small class="text-muted">Layout of the virtual address space of a process and the layout of the physical address
space. Note that if a machine has more than 2 Gbyte of physical memory, xv6 can use only the memory
that fits between KERNBASE and 0xFE00000</small>
    </center>
    <br><br>
    

<h3><p>§ Process address space</p></h3>

<p>
  The page table created by <code>entry</code> has enough mappings to
  allow the kernel's C code to start running.
  However, <code>main</code> immediately changes to a new page table by
  calling <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1840);">kvmalloc</a></code>, because the kernel has a more
  elaborate plan for describing process address spaces.
</p>

<p>
  Each process has a separate page table, and xv6 tells the page table
  hardware to switch page tables when xv6 switches between processes.
  As shown in  
    <a class="popoverOption" href="#fig2-2" data-content="<img src='figs/fig2-2.jpg' alt='figure 2-2'>" 
    rel="popover" data-placement="bottom" data-original-title="Figure 2-2">Figure 2-2</a>, a process's user memory
  starts at virtual address zero and can grow up to
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(207);">KERNBASE</a></code>, allowing a process to address up to 2 gigabytes
  of memory.  The file <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(200);">memlayout.h</a></code> declares the
  constants for xv6's memory layout, and macros to convert virtual to
  physical addresses.
</p>

<p>
  When a process asks xv6 for more memory, xv6 first finds free
  physical pages to provide the storage, and then adds PTEs to the
  process's page table that point to the new physical pages. xv6 sets
  the <code>PTE_U</code>, <code>PTE_W</code>, and </code>PTE_P</code>
  flags in these PTEs. Most processes do not use the entire user address
  space; xv6 leaves PTE_P clear in unused PTEs. Different processes'
  page tables translate user addresses to different pages of physical
  memory, so that each process has private user memory.
</p>

<p>
  Xv6 includes all mappings needed for the kernel to run in every
  process's page table; these mappings all appear above
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(207);">KERNBASE</a></code>.  It maps virtual addres
  KERNBASE|addr}}:<code><a onclick="event.stopPropagation()" href="javascript:gotoLine(207);">KERNBASE</a></code>+<code><a onclick="event.stopPropagation()" href="javascript:gotoLine(203);">PHYSTOP</a></code> to
  0:<code><a onclick="event.stopPropagation()" href="javascript:gotoLine(203);">PHYSTOP</a></code>. One reason for this mapping is so that the
  kernel can use its own instructions and data. Another reason is that
  the kernel sometimes needs to be able to write a given page of
  physical memory, for example when creating page table pages; having
  every physical page appear at a predictable virtual address makes
  this convenient.  A defect of this arrangement is that xv6 cannot
  make use of more than 2 gigabytes of physical memory, because the
  kernel part of the address space is 2 gigabytes.  Thus, xv6 requires
  that <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(203);">PHYSTOP</a></code> be smaller than 2 gigabytes, even if the
  computer has more than 2 gigabytes of physical memory.
</p>
  
<p>
  Some devices that use memory-mapped I/O appear at physical addresses
  starting at <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(204);">0xFE000000</a></code>, so xv6 page tables including a
  direct mapping for them.  Thus, <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(203);">PHYSTOP</a></code> must be smaller
  than two gigabytes - 16 megabytes (for the device memory).
</p>
  
<p>
  Xv6 does not set the <code>PTE_U</code> flag in the PTEs above
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(207);">KERNBASE</a></code>, so only the kernel can use them.
</p>

<p>
  Having every process's page table contain mappings for both user
  memory and the entire kernel is convenient when switching from user
  code to kernel code during system calls and interrupts: such
  switches do not require page table switches.  For the most part the
  kernel does not have its own page table; it is almost always
  borrowing some process's page table.
</p>

<p>
  To review, xv6 ensures that each process can use only its own
  memory.  And, each process sees its memory as having contiguous
  virtual addresses starting at zero, while the process's physical
  memory can be non-contiguous.  xv6 implements the first by setting
  the <code>PTE_U</code> bit only on PTEs of virtual addresses that
  refer to the process's own memory. It implements the second using
  the ability of page tables to translate successive virtual addresses
  to whatever physical pages happen to be allocated to the process.
</p>

 <h3><p>§ Code: creating an address space</p></h3>

<p>
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1217);">main</a></code> calls <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1840);">kvmalloc</a></code> to create and
  switch to a page table with the mappings above <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(207);">KERNBASE</a></code>
  required for the kernel to run.  Most of the work happens in
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1818);">setupkvm</a></code>. It first allocates a page of memory to
  hold the page directory. Then it calls <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1760);">mappages</a></code> to
  install the translations that the kernel needs, which are described
  in the <code>kmap</code> <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1809);"><small>(1809)</small></a></code> array.  The translations
  include the kernel's instructions and data, physical memory up to
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(203);">PHYSTOP</a></code>, and memory ranges which are actually I/O
  devices. <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1818);">setupkvm</a></code> does not install any mappings for
  the user memory; this will happen later.
</p>

<p>
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1760);">mappages</a></code> installs mappings into a page table for a
  range of virtual addresses to a corresponding range of physical
  addresses.  It does this separately for each virtual address in the
  range, at page intervals.  For each virtual address to be mapped,
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1760);">mappages</a></code> calls <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1735);">walkpgdir</a></code> to find the
  address of the PTE for that address.  It then initializes the PTE to
  hold the relevant physical page number, the desired permissions (
  <code>PTE_W</code> and/or <code>PTE_U</code>),
  and <code>PTE_P</code> to mark the <code><a onclick="event.stopPropagation()" href="javascript:gotoLines(1772, 1772);">PTE as valid</a></code>
</p>

<p>
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1735);">walkpgdir</a></code> mimics the actions of the x86 paging
  hardware as it looks up the PTE for a virtual address (see
   
    <a class="popoverOption" href="#fig2-1" data-content="<img src='figs/fig2-1.jpg' alt='figure 2-1'>" 
    rel="popover" data-placement="bottom" data-original-title="Figure 2-1">Figure 2-1</a>).  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1735);">walkpgdir</a></code> uses the
  upper 10 bits of the virtual address to find the page directory
  entry <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1740);"><small>(1740)</small></a></code> If the page directory entry isn't present, then
  the required page table page hasn't yet been allocated; if the .code
  alloc argument is set, <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1735);">walkpgdir</a></code> allocates it and
  puts its physical address in the page directory.  Finally it uses
  the next 10 bits of the virtual address to find the address of the
  PTE in the page table page <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1753);"><small>(1753)</small></a></code>.
</p>

  <h3><p>§ Physical memory allocation</p></h3>

<p>
  The kernel must allocate and free physical memory at run-time for
  page tables, process user memory, kernel stacks, and pipe buffers.
</p>

<p>
  xv6 uses the physical memory between the end of the kernel and <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(203);">PHYSTOP</a></code>
  for run-time allocation. It allocates and frees whole 4096-byte pages
  at a time. It keeps track of which pages are free by threading a
  linked list through the pages themselves. Allocation consists of
  removing a page from the linked list; freeing consists of adding the
  freed page to the list.
</p>

<p>
  There is a bootstrap problem: all of physical memory must be mapped
  in order for the allocator to initialize the <a href="https://www.memorymanagement.org/glossary/f.html#free.list" onclick="event.stopPropagation()" target="_blank">free
  list</a>,
  but creating a page table with those mappings involves allocating
  page-table pages.  xv6 solves this problem by using a separate page
  allocator during entry, which allocates memory just after the end of
  the kernel's data segment. This allocator does not support freeing
  and is limited by the 4 MB mapping in the <code>entrypgdir</code>,
  but that is sufficient to allocate the first kernel page table.
</p>

<h3><p>§ Code: Physical memory allocator</p></h3>

<p>
  The allocator's data structure is a <i>free list</i> of physical
  memory pages that are available for allocation.  Each free page's
  list element is a <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3115);">run</a></code> struct. Where does the allocator
  get the memory to hold that data structure?  It stores each free
  page's <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3115);">run</a></code> structure in the free page itself, since
  there's nothing else stored there.  The free list is protected by a
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLines(3119, 3123);">spin lock</a></code>. The list and the lock are wrapped in a
  struct to make clear that the lock protects the fields in the
  struct.  For now, ignore the lock and the calls to <code>acquire</code> and
  <code>release</code>; Chapter 4 will examine
  locking in detail.
</p>

<p>
  The function <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1217);">main</a></code> calls <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3131);">kinit1</a></code> and
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3139);">kinit2</a></code> to initialize the allocator
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3131);"><small>(3131)</small></a></code>. The reason for having two calls is that for much of
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1217);">main</a></code> one cannot use locks or memory above 4
  megabytes. The call to <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3131);">kinit1</a></code> sets up for lock-less
  allocation in the first 4 megabytes, and the call to
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3139);">kinit2</a></code> enables locking and arranges for more memory
  to be allocatable. <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1217);">main</a></code> ought to determine how much
  physical memory is available, but this turns out to be difficult on
  the x86.  Instead it assumes that the machine has 224 megabytes
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(203);">PHYSTOP</a></code> (of physical memory, and uses all the memory
  between the end of the kernel and <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(203);">PHYSTOP</a></code> as the initial
  pool of free memory.  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3131);">kinit1</a></code> and
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3139);">kinit2</a></code> call <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3151);">freerange</a></code> to add memory
  to the free list via per-page calls to <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3164);">kfree</a></code>. A PTE
  can only refer to a physical address that is aligned on a 4096-byte
  boundary (is a multiple of 4096), so <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3151);">freerange</a></code> uses
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(798);">PGROUNDUP</a></code> to ensure that it frees only aligned physical
  addresses.  The allocator starts with no memory; these calls to
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3164);">kfree</a></code> give it some to manage.
</p>

<p>
  The allocator refers to physical pages by their virtual addresses as
  mapped in high memory, not by their physical addresses, which is why
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3139);">kinit2</a></code> uses <code>P2V(PHYSTOP)</code> to translate
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(203);">PHYSTOP</a></code> (a physical address) to a virtual address.  The
  allocator sometimes treats addresses as integers in order to perform
  arithmetic on them (e.g., traversing all pages in kinit), and
  sometimes uses addresses as pointers to read and write memory (e.g.,
  manipulating the <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3115);">run</a></code> structure stored in each page);
  this dual use of addresses is the main reason that the allocator
  code is full of C type casts. The other reason is that freeing and
  allocation inherently change the type of the memory.
</p>

<p>
  The function <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3164);">kfree</a></code> begins by setting every byte in the
  memory being freed to the value 1. This will cause code that uses memory after freeing it
  (uses "dangling references") to read garbage instead of the old valid contents;
  hopefully that will cause such code to break faster. Then <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3164);">kfree</a></code> casts 
  <code>v</code> to a pointer to struct <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3115);">run</a></code>, records the
  old start of the free list in <code>r->next</code>, and sets the free list
  equal to <code>r</code>. <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3187);">kalloc</a></code> removes and returns the first
  element in the free list.
</p>

<h3><p>§ User part of an address space</p></h3>




    <br/>
    <img src="figs/fig2-3.jpg" alt="figure 2-3" class="img-thumbnail">
    <br>
    <br>
    <center>
      <b>Figure 2-3.</b>
      <small class="text-muted">Memory layout of a user process with its initial stack.</small>
    </center>
    <br><br>
    

<p>
   
    <a class="popoverOption" href="#fig2-3" data-content="<img src='figs/fig2-3.jpg' alt='figure 2-3'>" 
    rel="popover" data-placement="bottom" data-original-title="Figure 2-3">Figure 2-3</a> shows the layout of the user memory of an
  executing process in xv6. Each user process starts at address 0. The
  bottom of the address space contains the text for the user program,
  its data, and its stack.  The heap is above the stack so that the
  heap can expand when the process calls <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3801);">sbrk</a></code>. Note
  that the text, data, and stack sections are layed out contiguously
  in the process's address space but xv6 is free to use non-contiguous
  physical pages for those sections. For example, when xv6 expands a
  process's heap, it can use any free physical page for the new
  virtual page and then program the page table hardware to map the
  virtual page to the allocated physical page. This flexibility is a
  major advantage of using paging hardware.
</p>

<p>
  The stack is a single page, and is shown with the initial contents
  as created by exec.  Strings containing the command-line arguments,
  as well as an array of pointers to them, are at the very top of the
  stack.  Just under that are values that allow a program to start at
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1217);">main</a></code> as if the function call <code>main(argc, argv)</code>
  had just started. To guard a stack growing off the
  stack page, xv6 places a guard page right below the stack. The guard
  page is not mapped and so if the stack runs off the stack page, the
  hardware will generate an exception because it cannot translate the
  faulting address. A real-world operating system might allocate more
  space for the stack so that it can grow beyond one page.
</p>

<h3><p>§ Code: sbrk</p></h3>

<p>
  <code>Sbrk</code> is the system call for a process to shrink or grow
  its memory. The system call is implemented by the function
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2558);">growproc</a></code>. If <code>n</code> is postive,
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2558);">growproc</a></code> allocates one or more physical pages and
  maps them at the top of the process's address space.
  If <code>n</code> is negative, <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2558);">growproc</a></code> unmaps one
  or more pages from the process's address space and frees the
  corresponding physical pages. To make these changes, xv6 modifies
  the process's page table.  The process's page table is stored in
  memory, and so the kernel can update the table with ordinary
  assignment statements, which is what <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1927);">allocuvm</a></code> and
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1961);">deallocuvm</a></code> do.  The x86 hardware caches page table
  entries in a <i>Translation Look-aside Buffer (TLB)</i>, and when
  xv6 changes the page tables, it must invalidate the cached entries.
  If it didn't invalidate the cached entries, then at some point later
  the TLB might use an old mapping, pointing to a physical page that
  in the mean time has been allocated to another process, and as a
  result, a process might be able to scribble on some other process's
  memory. Xv6 invalidates stale cached entries, by
  reloading <a class="popoverOption" data-content="%cr3 is used when PG is set. CR3 enables the processor to locate
    the page table directory for the current task . Refer to Chapter 5 for
    a description of page tables and page translation." rel="popover"><code>%cr3</code></a>, the register that holds the address of
  the current page table.
</p>

<h3><p>§ Code: exec</p></h3>

<p>
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> is the system call that creates the user part
  of an address space.  It initializes the user part of an address
  space from a file stored in the file system. <code>Exec</code> opens
  the named binary <code>path</code> using <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(5790);">namei</a></code> which
  is explained in Chapter 6. Then, it reads the ELF
  header. Xv6 applications are described in the widely-used <i>ELF
  format</i>, defined in <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(900);">elf.h</a></code>. An ELF binary consists
  of an ELF header, <code>struct</code> <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(905);">elfhdr</a></code>, followed
  by a sequence of program section headers, <code>struct</code>
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(924);">proghdr</a></code>. Each <code>proghdr</code> describes a section
  of the application that must be loaded into memory; xv6 programs
  have only one program section header, but other systems might have
  separate sections for instructions and data.
</p>

<p>
  The first step is a quick check that the file probably contains an
  ELF binary. An ELF binary starts with the four-byte "magic number"
  <code> 0x7F</code>, <code> 'E'</code>, <code> 'L'</code>, <code> 'F'</code>,
  or <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(902);">ELF_MAGIC</a></code>. If the ELF header has the right magic number,
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> assumes that the binary is well-formed.
</p>

<p>
  <code>Exec</code> allocates a new page table with no user mappings
  with <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1818);">setupkvm</a></code> allocates memory for each ELF segment
  with <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1927);">allocuvm</a></code> and loads each segment into memory
  with <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1903);">loaduvm</a></code>. <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1927);">allocuvm</a></code> checks that
  the virtual addresses requested is below
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(207);">KERNBASE</a></code>. <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1903);">loaduvm</a></code> uses
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1735);">walkpgdir</a></code> to find the physical address of the
  allocated memory at which to write each page of the ELF segment, and
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(5503);">readi</a></code> to read from the file.
</p>

<p>
  The program section header for <code>init</code>, the first user program created with
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code>, looks like this:
</p>

<div class="highlight"><pre><span></span>$ objdump -p _init
</pre></div>



<pre>
  
_init:     file format elf32-i386

Program Header:
    LOAD off    0x00000054 vaddr 0x00000000 paddr 0x00000000 align 2**2
         filesz 0x000008c0 memsz 0x000008cc flags rwx
</pre>

<p>
  The program section header's <code>filesz</code> may be less than the
  <code>memsz</code>, indicating that the gap between them should be filled
  with zeroes (for C global variables) rather than read from the file. For
  <code>init</code>, <code>filesz</code> is 2240 bytes
  and <code>memsz</code> is 2252 bytes, and thus
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1927);">allocuvm</a></code> allocates enough physical memory to hold
  2252 bytes, but reads only 2240 bytes from the
  file <code>init</code>.
</p>

<p>
  Now <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> allocates and initializes the user
  stack. It allocates just one stack page. <code>Exec</code> copies
  the argument strings to the top of the stack one at a time,
  recording the pointers to them
  in <code>ustack</code><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6671);"><small>(6671)</small></a></code>. It places<code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6679);"><small>(6679)</small></a></code> a null pointer at the
  end of what will be the <code>argv</code> list passed to
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1217);">main</a></code>.  The first three entries<code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6681);"><small>(6681)</small></a></code> in ustack are the
  fake return PC, <code>argc</code>, and <code>argv</code> pointer.
</p>

<p>
  <code>Exec</code> places an inaccessible page just below the stack
  page, so that programs that try to use more than one page will
  fault.  This inaccessible page also allows <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> to
  deal with arguments that are too large; in that situation, the
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2118);">copyout</a></code> function that <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> uses to
  copy arguments to the stack will notice that the destination page is
  not accessible, and will return <code>-1</code>.
</p>

<p>
  During the preparation of the new memory image, if
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> detects an error like an invalid program
  segment, it jumps to the label <code>bad</code>, frees the new image
  and returns -1. <code>Exec</code> must wait to free the old image
  until it is sure that the system call will succeed: if the old image
  is gone, the system call cannot return -1 to it.  The only error
  cases in <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> happen during the creation of the
  image.  Once the image is complete, <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> can install
  the new image <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6701);"><small>(6701)</small></a></code> and free the old one <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6702);"><small>(6702)</small></a></code>. Finally, <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> returns 0.
</p>

<p>
  Exec loads bytes from the ELF file into memory at addresses
  specified by the ELF file.  Users or processes can place whatever
  addresses they want into an ELF file.  Thus <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> is
  risky, because the addresses in the ELF file may refer to the
  kernel, accidentally or on purpose. The consequences for an unwary
  kernel could range from a crash to a malicious subversion of the
  kernel's isolation mechanisms (i.e., a security exploit).  xv6
  performs a number of checks to avoid these risks.  To understand the
  importance of these checks, consider what could happen if xv6 didn't
  check <code>if(ph.vaddr + ph.memsz < ph.vaddr)</code> This is a
  check for whether the sum overflows a 32-bit integer.  The danger is
  that a user could construct an ELF binary with
  a <code>ph.vaddr</code> that points into the kernel,
  and <code>ph.memsz</code> large enough that the sum overflows to
  0x1000.  Since the sum is small, it would pass the
  check <code>if(newsz >= KERNBASE)</code> in
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1927);">allocuvm</a></code>. The subsequent call to
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1903);">loaduvm</a></code> passes <code>ph.vaddr</code> by itself,
  without adding <code>ph.memsz</code> and without
  checking <code>ph.vaddr</code> against <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(207);">KERNBASE</a></code>, and
  would thus copy data from the ELF binary into the kernel. This could
  be exploited by a user program to run arbitrary user code with
  kernel privileges.  As this example illustrates, argument checking
  must be done with great care. It is easy for a kernel developer to
  omit a crucial check, and real-world kernels have a long history of
  missing checks whose absence can be exploited by user programs to
  obtain kernel privileges.  It is likely that xv6 doesn't do a
  complete job of validating user-level data supplied to the kernel,
  which a malicious user program might be able to exploit to
  circumvent xv6's isolation.
</p>

<h3><p>§ Real world</p></h3>

<p>
  Like most operating systems, xv6 uses the paging hardware for memory
  protection and mapping. Most operating systems use x86's 64-bit
  paging hardware (which has 3 levels of translation). 64-bit address
  spaces allow for a less restrictive memory layout than xv6's; for
  example, it would be easy to remove xv6's limit of 2 gigabytes for
  physical memory.  Most operating systems make far more sophisticated
  use of paging than xv6; for example, xv6 lacks demand paging from
  disk, copy-on-write fork, shared memory, lazily-allocated pages, and
  automatically extending stacks.  The x86 supports address
  translation using segmentation <a onclick="event.stopPropagation()" href="this will be a link">Appendix BOOT</a>, but xv6 uses
  segments only for the common trick of implementing per-cpu variables
  such as <code>proc</code> that are at a fixed address but have
  different values on different CPUs (see
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1715);">seginit</a></code>). Implementations of per-CPU (or per-thread)
  storage on non-segment architectures would dedicate a register to
  holding a pointer to the per-CPU data area, but the x86 has so few
  general registers that the extra effort required to use segmentation
  is worthwhile.
</p>

<p>
  Xv6 maps the kernel in the address space of each user process but sets it up so
  that the kernel part of the address space is inaccessible when the processor is
  in user mode.  This setup is convenient because after a process switches from
  user space to kernel space, the kernel can easily access user memory by reading
  memory locations directly.  It is probably better for security, however, to have
  a separate page table for the kernel and switch to that page table when entering
  the kernel from user mode, so that the kernel and user processes are more
  separated from each other.  This design, for example, would help mitigating
  side-channels that are exposed by the Meltdown vulnerability and that allow a
  user process to read arbitrary kernel memory.
</p>

<p>
  On machines with lots of memory it might make sense to use the x86's
  4-megabytes "super pages."  Small pages make sense when physical
  memory is small, to allow allocation and page-out to disk with fine
  granularity. For example, if a program uses only 8 kilobytes of
  memory, giving it a 4 megabytes physical page is wasteful. Larger
  pages make sense on machines with lots of RAM, and may reduce
  overhead for page-table manipulation.

  Xv6 uses super pages in one place: the initial page table
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1306);"><small>(1306)</small></a></code> The array initialization sets two of the 1024 PDEs, at
  indices zero and 512 <code>(KERNBASE>>PDXSHIFT)</code>, leaving the
  other PDEs zero.  Xv6 sets the <code>PTE_PS</code> bit in these two
  PDEs to mark them as super pages.  The kernel also tells the paging
  hardware to allow super pages by setting the <code>CR_PSE</code> bit
  (Page Size Extension) in <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%cr4</code></a>.
</p>

<p>
  Xv6 should determine the actual RAM configuration, instead of
  assuming 224 MB.  On the x86, there are at least three common
  algorithms: the first is to probe the physical address space looking
  for regions that behave like memory, preserving the values written to
  them; the second is to read the number of kilobytes of memory out of a
  known 16-bit location in the PC's non-volatile RAM; and the third is
  to look in BIOS memory for a memory layout table left as part of the
  multiprocessor tables.  Reading the memory layout table is complicated.
</p>

<p>
  Memory allocation was a hot topic a long time ago, the basic
  problems being efficient use of limited memory and preparing for
  unknown future requests; see Knuth. Today people care more about
  speed than space-efficiency. In addition, a more elaborate kernel
  would likely allocate many different sizes of small blocks, rather
  than (as in xv6) just 4096-byte blocks; a real kernel allocator
  would need to handle small allocations as well as large ones.
</p>

<h3><p>§ Exercises</p></h3>

<p>
  1. Look at real operating systems to see how they size memory.
</p>

<p>
  2. If xv6 had not used super pages, what would be the right
  declaration for <code>entrypgdir</code>?
</p>

<p>
  3. Write a user program that grows its address space with 1 byte by
  calling <code>sbrk(1)</code>. Run the program and investigate the
  page table for the program before the call to <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3801);">sbrk</a></code>
  and after the call to <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3801);">sbrk</a></code>. How much space has the
  kernel allocated?  What does the
  <code>pte</code> for the new memory contain?
</p>

<p>
  4. Modify xv6 so that the pages for the kernel are shared among
  processes, which reduces memory consumption.
</p>

<p>
  5. Modify xv6 so that when a user program dereferences a null
  pointer, it will receive a fault.  That is, modify xv6 so that virtual
  address 0 isn't mapped for user programs.
</p>

<p>
  6. Unix implementations of <code> exec </code> traditionally include
  special handling for shell scripts.  If the file to execute begins
  with the text <code>#!</code>, then the first line is taken to be a
  program to run to interpret the file.  For example, if
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> is called to run <code>myprog
  arg1</code>myprog's</code> first line is <code>#!/interp</code>,
  then <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> runs <code>interp</code> with command
  line <code>interp myprog arg1</code>. Implement support for this convention in xv6.
</p>

<p>
  7. Delete the check <code>if(ph.vaddr + ph.memsz &lt ph.vaddr)</code> in
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6600);">exec.c</a></code>, and construct a user program that exploits that
  the check is missing.
</p>

<p>
  8. Change xv6 so that user processes run with only a minimal part of the kernel
  mapped and so that the kernel runs with its own page table that doesn't include
  the user process.
</p>

<p>
  9. How would you improve xv6's memory layout if xv6 where running on a 64-bit
  processor?
</p>
          


<hr>
<h1><a name="chapter3">CHAPTER 3</a></h1>

<h1>Traps, interrupts and drivers</h1>

<div>
  <p>
    When running a process, a CPU executes the normal processor loop:
    read an instruction, advance the program counter, execute the
    instruction, repeat.  But there are events on which control from a
    user program must transfer back to the kernel instead of executing
    the next instruction.  These events include a device signaling
    that it wants attention, a user program doing something illegal
    (e.g., references a virtual address for which there is no page
    table entry), or a user program asking the kernel for a service
    with a system call.  There are three main challenges in handling
    these events: 1) the kernel must arrange that a processor switches
    from user mode to kernel mode (and back); 2) the kernel and
    devices must coordinate their parallel activities; and 3) the
    kernel must understand the interface of the devices.  Addressing
    these 3 challenges requires detailed understanding of hardware and
    careful programming, and can result in opaque kernel code.  This
    chapter explains how xv6 addresses these three challenges.
  </p>
    
  <h3><p>§ Systems calls, exceptions, and interrupts</p></h3>

  <p>
    There are three cases when control must be transferred from a user
    program to the kernel. First, a system call: when a user program
    asks for an operating system service, as we saw at the end of the
    last chapter.  Second, an <i>exception</i>: when a program
    performs an illegal action. Examples of illegal actions include
    divide by zero, attempt to access memory for a page-table entry
    that is not present, and so on.  Third, an <i>interrupt</i> when a
    device generates a signal to indicate that it needs attention from
    the operating system.  For example, a clock chip may generate an
    interrupt every 100 msec to allow the kernel to implement time
    sharing. As another example, when the disk has read a block from
    disk, it generates an interrupt to alert the operating system that
    the block is ready to be retrieved.
  </p>
  
  <p>
    The kernel handles all interrupts, rather than processes handling
    them, because in most cases only the kernel has the required privilege
    and state. For example, in order to time-slice among processes in
    response the clock interrupts, the kernel must be involved, if only to
    force uncooperative processes to yield the processor.    
  </p>

  <p>
    In all three cases, the operating system design must arrange for
    the following to happen.  The system must save the processor's
    registers for future transparent resume.  The system must be set up
    for execution in the kernel.  The system must chose a place for the
    kernel to start executing. The kernel must be able to retrieve
    information about the event, e.g., system call arguments.  It must all
    be done securely; the system must maintain isolation of user processes
    and the kernel.    
  </p>

  <p>
    To achieve this goal the operating system must be aware of the
    details of how the hardware handles system calls, exceptions, and
    interrupts.  In most processors these three events are handled by a
    single hardware mechanism.  For example, on the x86, a program invokes
    a system call by generating an interrupt using the <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a>
    instruction.  Similarly, exceptions generate an interrupt too. Thus,
    if the operating system has a plan for interrupt handling, then the
    operating system can handle system calls and exceptions too.
  </p>

  <p>
    The basic plan is as follows.  An interrupt stops the normal
    processor loop and starts executing a new sequence called an
    <i>interrupt handler</i>.  Before starting the interrupt
    handler, the processor saves its registers, so that the operating
    system can restore them when it returns from the interrupt. A
    challenge in the transition to and from the interrupt handler is that
    the processor should switch from user mode to kernel mode, and back.
  </p>

  <p>
    A word on terminology: Although the official x86 term is
    exception, xv6 uses the term <i>trap</i>, largely because it was
    the term used by the PDP11/40 and therefore is the conventional
    Unix term.  Furthermore, this chapter uses the terms trap and
    interrupt interchangeably, but it is important to remember that
    traps are caused by the current process running on a processor
    (e.g., the process makes a system call and as a result generates a
    trap), and interrupts are caused by devices and may not be related
    to the currently running process.  For example, a disk may
    generate an interrupt when it is done retrieving a block for one
    process, but at the time of the interrupt some other process may
    be running. This property of interrupts makes thinking about
    interrupts more difficult than thinking about traps, because
    interrupts happen concurrently with other activities. Both rely,
    however, on the same hardware mechanism to transfer control
    between user and kernel mode securely, which we will discuss next.    
  </p>
  
<h3><p>§ X86 protection</p></h3>

  <p>
    The x86 has 4 protection levels, numbered 0 (most privilege) to 3
    (least privilege).  In practice, most operating systems use only 2
    levels: 0 and 3, which are then called <i>kernel mode</i> and 
    <i>user mode</i>, respectively.  The current privilege level with
    which the x86 executes instructions is stored in <a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a>
    register, in the field CPL.
  </p>
  
  <p>
    On the x86, interrupt handlers are defined in the interrupt
    descriptor table (IDT). The IDT has 256
    entries, each giving the <a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a> and <a class="popoverOption" data-content="intruction pointer register." rel="popover"><code>%eip</code></a> to be used
    when handling the corresponding interrupt.
  </p>
  
  <p>
    To make a system call on the x86, a program invokes the
    <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a> <i>n</i> instruction, where <i>n</i> specifies the
    index into the IDT. The <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a> instruction
    performs the following steps:
  </p>
  <p>
    ■ Fetch the <i>n</i>'th descriptor from the IDT,
    where <i>n</i> is the argument of <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a>.
  </p>
  <p>
    ■ Check that CPL in <a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a> is less than or equal
    to DPL</code>, where <code>DPL</code> is the
    privilege level in the descriptor.
  </p>
      
  <p>
    ■ Save <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a> and <a class="popoverOption" data-content="The stack segment (SS) register. Stacks are implemented in
    memory. A system may have a number of stacks that is limited only by
    the maximum number of segments. A stack may be up to 4 gigabytes long,
    the maximum length of a segment. One stack is directly addressable at
    a -- one located by SS. This is the current stack, often referred to
    simply as 'the' stack. SS is used automatically by the processor for
    all stack operations." rel="popover"><code>%ss</code></a> in CPU-internal registers, but only if the target segment
    selector's PL &lt CPL.
  </p>
  
  <p> ■ Load <a class="popoverOption" data-content="The stack segment (SS) register. Stacks are implemented in
    memory. A system may have a number of stacks that is limited only by
    the maximum number of segments. A stack may be up to 4 gigabytes long,
    the maximum length of a segment. One stack is directly addressable at
    a -- one located by SS. This is the current stack, often referred to
    simply as 'the' stack. SS is used automatically by the processor for
    all stack operations." rel="popover"><code>%ss</code></a> and <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a> from a task segment descriptor. </p>

  <p> ■ Push <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a>. </p>
  <p> ■ Push <a class="popoverOption" data-content="The status flags of the EFLAGS register allow the results of one
    instruction to influence later instructions. The arithmetic
    instructions use OF, SF, ZF, AF, PF, and CF. The SCAS (Scan String),
    CMPS (Compare String), and LOOP instructions use ZF to signal that
    their operations are complete. There are instructions to set, clear,
    and complement CF before execution of an arithmetic instruction. Refer
    to Appendix C for definition of each status flag." rel="popover"><code>%eflags</code></a>. </p>
  <p> ■ Push <a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a>. </p>
  <p> ■ Push <a class="popoverOption" data-content="intruction pointer register." rel="popover"><code>%eip</code></a>. </p>
  <p> ■ Clear the IF bit in <a class="popoverOption" data-content="The status flags of the EFLAGS register allow the results of one
    instruction to influence later instructions. The arithmetic
    instructions use OF, SF, ZF, AF, PF, and CF. The SCAS (Scan String),
    CMPS (Compare String), and LOOP instructions use ZF to signal that
    their operations are complete. There are instructions to set, clear,
    and complement CF before execution of an arithmetic instruction. Refer
    to Appendix C for definition of each status flag." rel="popover"><code>%eflags</code></a>, but only on an interrupt. </p>
  <p> ■ Set <a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a> and <a class="popoverOption" data-content="intruction pointer register." rel="popover"><code>%eip</code></a> to the values in the descriptor. </p>
  
  <p>
    The <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a> instruction is a complex instruction, and one
    might wonder whether all these actions are necessary.  For
    example, the check CPL &lt= DPL allows the
    kernel to forbid <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a> calls to inappropriate
    IDT entries such as device interrupt routines.  For a
    user program to execute <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a>, the IDT entry's
    DPL must be 3.  If the user program doesn't have the
    appropriate privilege, then <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a> will result
    in <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a> 13, which is a general protection fault.  As
    another example, the <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a> instruction cannot use the
    user stack to save values, because the process may not have a
    valid stack pointer; instead, the hardware uses the stack
    specified in the task segment, which is set by the kernel.
  </p>
  
    <br/>
    <img src="figs/fig3-1.jpg" alt="figure 3-1" class="img-thumbnail">
    <br>
    <br>
    <center>
      <b>Figure 3-1.</b>
      <small class="text-muted">Kernel stack after an int instruction.</small>
    </center>
    <br><br>
    

  <p>
     
    <a class="popoverOption" href="#fig3-1" data-content="<img src='figs/fig3-1.jpg' alt='figure 3-1'>" 
    rel="popover" data-placement="bottom" data-original-title="Figure 3-1">Figure 3-1</a> shows the stack after an int instruction
    completes and there was a privilege-level change (the privilege
    level in the descriptor is lower than CPL).  If the <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a>
    instruction didn't require a privilege-level change, the x86 won't
    save <a class="popoverOption" data-content="The stack segment (SS) register. Stacks are implemented in
    memory. A system may have a number of stacks that is limited only by
    the maximum number of segments. A stack may be up to 4 gigabytes long,
    the maximum length of a segment. One stack is directly addressable at
    a -- one located by SS. This is the current stack, often referred to
    simply as 'the' stack. SS is used automatically by the processor for
    all stack operations." rel="popover"><code>%ss</code></a> and <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a>. After both cases,
    <a class="popoverOption" data-content="intruction pointer register." rel="popover"><code>%eip</code></a> is pointing to the address specified in the
    descriptor table, and the instruction at that address is the next
    instruction to be executed and the first instruction of the
    handler for <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a> <i>n</i>. It is job of the operating
    system to implement these handlers, and below we will see what xv6
    does.
  </p>
  <p>
    An operating system can use the <a class="popoverOption" data-content="
    IRET: returns from an interrupt service routine (ISR). 
    " rel="popover"><u>iret</u></a> instruction to
    return from an <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a> instruction. It pops the saved
    values during the <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a> instruction from the stack, and
    resumes execution at the saved <a class="popoverOption" data-content="intruction pointer register." rel="popover"><code>%eip</code></a>.
  </p>


  <h3><p>§ Code: The first system call</p></h3>
  
  <p>
    1 ended with <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8400);">initcode.S</a></code> invoking a system call.
    Let's look at that again <code>T_SYSCALL</code><code><a onclick="event.stopPropagation()" href="javascript:gotoLine(8414);"><small>(8414)</small></a></code>. The process pushed the arguments
    for an <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> call on the process's stack, and put the system call number in
    <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%eax</code></a>. The system call numbers match the entries in the syscalls array,
    a table of function pointers syscalls <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3673);"><small>(3673)</small></a></code>. We need to arrange that the 
    <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a> instruction switches the processor from user mode to kernel mode,
    that the kernel invokes the right kernel function (i.e., <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6526);">sys_exec</a></code>),
    and that the kernel can retrieve the arguments for <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6526);">sys_exec</a></code>.
    The next few subsections describe how xv6 arranges this for system
    calls, and then we will discover that we can reuse the same code for
    interrupts and exceptions.
  </p>
  
    <h3><p>§ Code: Assembly trap handlers</p></h3>
  <p>
    Xv6 must set up the x86 hardware to do something sensible on
    encountering an <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a> instruction, which causes the
    processor to generate a trap.  The x86 allows for 256 different
    interrupts. Interrupts 0-31 are defined for software exceptions,
    like divide errors or attempts to access invalid memory addresses.
    Xv6 maps the 32 hardware interrupts to the range 32-63 and uses
    interrupt 64 as the system call interrupt.    
  </p>
<p>
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3367);">tvinit</a></code> called from <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1217);">main</a></code>, sets up the 256 entries in the table
  <code>idt</code>. Interrupt <code>i</code> is handled by the code at the address in
  <code>vectors[i]</code>. Each entry point is different, because the
  x86 does not provide the trap number to the interrupt handler.  Using
  256 different handlers is the only way to distinguish the 256 cases.
</p>

<p>
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3367);">tvinit</a></code> handles <code>T_SYSCALL</code>, the user system call trap,
  specially: it specifies that the gate is of type ``trap'' by passing a value of
  <code>1</code> as second argument. Trap gates don't clear the <code>IF</code>
  flag, allowing other interrupts during the system call handler. 
</p>

<p>
  The kernel also sets the system call gate privilege
  to <code>DPL_USER</code>, which allows a user program to generate
  the trap with an explicit <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a> instruction. xv6 doesn't
  allow processes to raise other interrupts (e.g., device interrupts)
  with <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a>; if they try, they will encounter a general
  protection exception, which goes to vector 13.
</p>

<p>
  When changing protection levels from user to kernel mode, the kernel
  shouldn't use the stack of the user process, because it may not be valid.
  The user process may be malicious or
  contain an error that causes the user <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a> 
  to contain an address that is not part of the process's user memory.
  Xv6 programs the x86 hardware to perform a stack switch on a trap by
  setting up a task segment descriptor through which the hardware loads a stack
  segment selector and a new value for <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a>. The function
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(1860);">switchuvm</a></code> stores the address of the top of the kernel stack of the user
  process into the task segment descriptor.
</p>

<p>
  When a trap occurs, the processor hardware does the following.
  If the processor was executing in user mode,
  it loads <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a> and <a class="popoverOption" data-content="The stack segment (SS) register. Stacks are implemented in
    memory. A system may have a number of stacks that is limited only by
    the maximum number of segments. A stack may be up to 4 gigabytes long,
    the maximum length of a segment. One stack is directly addressable at
    a -- one located by SS. This is the current stack, often referred to
    simply as 'the' stack. SS is used automatically by the processor for
    all stack operations." rel="popover"><code>%ss</code></a> from the task segment descriptor,
  pushes the old user <a class="popoverOption" data-content="The stack segment (SS) register. Stacks are implemented in
    memory. A system may have a number of stacks that is limited only by
    the maximum number of segments. A stack may be up to 4 gigabytes long,
    the maximum length of a segment. One stack is directly addressable at
    a -- one located by SS. This is the current stack, often referred to
    simply as 'the' stack. SS is used automatically by the processor for
    all stack operations." rel="popover"><code>%ss</code></a> and <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a> onto the new stack.
  If the processor was executing in kernel mode, none of the above happens.
  The processor then pushes the <a class="popoverOption" data-content="The status flags of the EFLAGS register allow the results of one
    instruction to influence later instructions. The arithmetic
    instructions use OF, SF, ZF, AF, PF, and CF. The SCAS (Scan String),
    CMPS (Compare String), and LOOP instructions use ZF to signal that
    their operations are complete. There are instructions to set, clear,
    and complement CF before execution of an arithmetic instruction. Refer
    to Appendix C for definition of each status flag." rel="popover"><code>%eflags</code></a>, <a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a>, and
  <a class="popoverOption" data-content="intruction pointer register." rel="popover"><code>%eip</code></a> registers.  For some traps (e.g., a page fault), the processor also pushes an
  error word.  The processor then loads <a class="popoverOption" data-content="intruction pointer register." rel="popover"><code>%eip</code></a>
  and <a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a> from the relevant IDT entry.
</p>

<p>
  xv6 uses a Perl script <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3250);">vectors.pl</a></code> to generate the entry
  points that the IDT entries point to.  Each entry pushes
  an error code if the processor didn't, pushes the interrupt number,
  and then jumps to <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3304);">alltraps</a></code>.
</p>


    <br/>
    <img src="figs/fig3-2.jpg" alt="figure 3-2" class="img-thumbnail">
    <br>
    <br>
    <center>
      <b>Figure 3-2.</b>
      <small class="text-muted">The trapframe on the kernel stack</small>
    </center>
    <br><br>
    

<p>

  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3304);">alltraps</a></code> continues to save processor registers: it pushes
  <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%ds</code></a>, <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%es</code></a>, <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%fs</code></a>, <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%gs</code></a>,  
  and the general-purpose registers .lines trapasm.S:/Build.trap.frame/,/pushal/ .
  The result of this effort is that the kernel stack now contains a
  <code>struct trapframe</code> .line x86.h:/trapframe/ containing the
  processor registers at the time of the trap (see
   
    <a class="popoverOption" href="#fig3-2" data-content="<img src='figs/fig3-2.jpg' alt='figure 3-2'>" 
    rel="popover" data-placement="bottom" data-original-title="Figure 3-2">Figure 3-2</a>). The processor pushes <a class="popoverOption" data-content="The stack segment (SS) register. Stacks are implemented in
    memory. A system may have a number of stacks that is limited only by
    the maximum number of segments. A stack may be up to 4 gigabytes long,
    the maximum length of a segment. One stack is directly addressable at
    a -- one located by SS. This is the current stack, often referred to
    simply as 'the' stack. SS is used automatically by the processor for
    all stack operations." rel="popover"><code>%ss</code></a>,
  <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a>, <a class="popoverOption" data-content="The status flags of the EFLAGS register allow the results of one
    instruction to influence later instructions. The arithmetic
    instructions use OF, SF, ZF, AF, PF, and CF. The SCAS (Scan String),
    CMPS (Compare String), and LOOP instructions use ZF to signal that
    their operations are complete. There are instructions to set, clear,
    and complement CF before execution of an arithmetic instruction. Refer
    to Appendix C for definition of each status flag." rel="popover"><code>%eflags</code></a>, <a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a>, and
  <a class="popoverOption" data-content="intruction pointer register." rel="popover"><code>%eip</code></a>. The processor or the trap vector pushes an error
  number, and <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3304);">alltraps</a></code> pushes the rest. The trap frame
  contains all the information necessary to restore the user mode
  processor registers when the kernel returns to the current process,
  so that the processor can continue exactly as it was when the trap
  started.  Recall from Chapter 2, that <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(2520);">userinit</a></code>
  built a trapframe by hand to achieve this goal (see .figref first:newkernelstack ).
</p>
<p>

  In the case of the first system call, the saved <a class="popoverOption" data-content="intruction pointer register." rel="popover"><code>%eip</code></a> is the
  address of the instruction right after the <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a>
  instruction. <a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a> is the user code segment
  selector. <a class="popoverOption" data-content="The status flags of the EFLAGS register allow the results of one
    instruction to influence later instructions. The arithmetic
    instructions use OF, SF, ZF, AF, PF, and CF. The SCAS (Scan String),
    CMPS (Compare String), and LOOP instructions use ZF to signal that
    their operations are complete. There are instructions to set, clear,
    and complement CF before execution of an arithmetic instruction. Refer
    to Appendix C for definition of each status flag." rel="popover"><code>%eflags</code></a> is the content of the <a class="popoverOption" data-content="The status flags of the EFLAGS register allow the results of one
    instruction to influence later instructions. The arithmetic
    instructions use OF, SF, ZF, AF, PF, and CF. The SCAS (Scan String),
    CMPS (Compare String), and LOOP instructions use ZF to signal that
    their operations are complete. There are instructions to set, clear,
    and complement CF before execution of an arithmetic instruction. Refer
    to Appendix C for definition of each status flag." rel="popover"><code>%eflags</code></a>
  register at the point of executing the <a class="popoverOption" data-content="INT is an instruction for that generates a software interrupt. It takes the
    interrupt number formatted as a byte value." rel="popover"><u>int</u></a>
  instruction. As part of saving the general-purpose registers,
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3304);">alltraps</a></code> also saves <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%eax</code></a>, which contains the
  system call number for the kernel to inspect later.
</p>
<p>
  Now that the user mode processor registers are saved, <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3304);">alltraps</a></code>
  can finishing setting up the processor to run kernel C code. The processor set the selectors
  <a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a> and <a class="popoverOption" data-content="The stack segment (SS) register. Stacks are implemented in
    memory. A system may have a number of stacks that is limited only by
    the maximum number of segments. A stack may be up to 4 gigabytes long,
    the maximum length of a segment. One stack is directly addressable at
    a -- one located by SS. This is the current stack, often referred to
    simply as 'the' stack. SS is used automatically by the processor for
    all stack operations." rel="popover"><code>%ss</code></a> before entering the handler; <code><a onclick="event.stopPropagation()" href="javascript:gotoLines(3313, 3315);">alltraps</a></code> sets
  <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%ds</code></a> and <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%es</code></a>.
</p>
<p>
  Once the segments are set properly, <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3304);">alltraps</a></code> can call the C trap handler
  <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3401);">trap</a></code>. It pushes <a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a>, which points at the trap frame it just constructed,
  onto the stack as an argument to <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(3401);">trap</a></code> .line "'trapasm.S:/pushl.%esp/'" .
  Then it calls .code trap
  .line trapasm.S:/call.trap/ .
  After
  .code trap 
  returns,
  .code-index alltraps
  pops the argument off the stack by
  adding to the stack pointer
  .line trapasm.S:/addl/
  and then starts executing the code at label
  .code-index trapret .
  We traced through this code in Chapter \*[CH:MEM]
  when the first user process ran it to exit to user space.
  The same sequence happens here: popping through
  the trap frame restores the user mode registers and then
  .code-index iret
  jumps back into user space.
  
</p><p>

The discussion so far has talked about traps occurring in user mode,
but traps can also happen while the kernel is executing.
In that case the hardware does not switch stacks or save
the stack pointer or stack segment selector;
otherwise the same steps occur as in traps from user mode,
and the same xv6 trap handling code executes.
When 
.code iret
later restores a kernel mode 
<a class="popoverOption" data-content="The segment containing the currently executing sequence of
    instructions is known as the current code segment; it is specified by
    means of the CS register. The 80386 fetches all instructions from this
    code segment, using as an offset the contents of the instruction
    pointer. CS is changed implicitly as the result of intersegment
    control-transfer instructions (for example, CALL and JMP), interrupts,
    and exceptions." rel="popover"><code>%cs</code></a>,
the processor continues executing in kernel mode.
<h3><p>§ Code: C trap handler</p></h3>

</p><p>
<!--
We saw in the last section that each handler sets
up a trap frame and then calls the C function
.code-index trap .
.code Trap
.line 'trap.c:/^trap!(/'
looks at the hardware trap number
.code-index tf->trapno
to decide why it has been called and what needs to be done.
If the trap is
.code-index T_SYSCALL ,
.code trap
calls the system call handler
.code-index syscall .
We'll revisit the 
.code-index proc->killed
checks in Chapter \*[CH:SCHED].  \" XXX really?

</p><p>

After checking for a system call, trap looks for hardware interrupts
(which we discuss below). In addition to the expected hardware
devices, a trap can be caused by a spurious interrupt, an unwanted
hardware interrupt.
.ig
give a concrete example.
..

</p><p>

If the trap is not a system call and not a hardware device looking for
attention,
.code-index trap
assumes it was caused by incorrect behavior (e.g.,
divide by zero) as part of the code that was executing before the
trap.  
If the code that caused the trap was a user program, xv6 prints
details and then sets
.code proc->killed
to remember to clean up the user process.
We will look at how xv6 does this cleanup in Chapter \*[CH:SCHED].
</p>
  <p>
    If it was the kernel running, there must be a kernel bug:
    <code>trap</code> prints details about the surprise and then calls
    <code>panic</code>.
  </p>
  
    <h3><p>§ System calls</p></h3>
  
  <p>
    For system calls,
    .code-index trap
    invokes
    .code-index syscall
    .line syscall.c:/'^syscall'/ .
    .code Syscall 
    loads the system call number from the trap frame, which
    contains the saved
    <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%eax</code></a>,
    and indexes into the system call tables.
    For the first system call, 
    <a class="popoverOption" data-content="UNKNOWN REGISTER" rel="popover"><code>%eax</code></a>
    contains the value 
    .code-index SYS_exec
    .line syscall.h:/'SYS_exec'/ ,
    and
    .code syscall
    will invoke the 
    .code SYS_exec 'th 
    entry of the system call table, which corresponds to invoking
    .code sys_exec .
  </p>
  <p>
    <code>Syscall</code> records the return value of the system call function in
    <code>%eax</code>. When the trap returns to user space, it will
    load the values from <code>cp->tf</code> into the machine
    registers. Thus, when <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(6610);">exec</a></code> returns, it will return the value
    that the system call handler returned .line "'syscall.c:/eax =
    syscalls/'" .  System calls conventionally return negative numbers
    to indicate errors, positive numbers for success.  If the system
    call number is invalid, <code>syscall</code> prints an error and
    returns -1.

      </p><p>
  
Later chapters will examine the implementation of
particular system calls.
This chapter is concerned with the mechanisms for system calls.
There is one bit of mechanism left: finding the system call arguments.
The helper functions argint, argptr, argstr, and argfd retrieve the 
.italic n 'th 
system call
argument, as either an integer, pointer, a string, or a file descriptor.
.code-index argint 
uses the user-space 
<a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a> 
register to locate the 
.italic n'th 
argument:
<a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a> 
points at the return address for the system call stub.
The arguments are right above it, at 
<a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a>+4.
Then the nth argument is at 
<a class="popoverOption" data-content="The stack pointer (ESP) register. ESP points to the top of the
    push-down stack (TOS). It is referenced implicitly by PUSH and POP
    operations, subroutine calls and returns, and interrupt
    operations. When an item is pushed onto the stack,
    the processor decrements ESP, then writes the item at the new
    TOS. When an item is popped off the stack, the processor copies it
    from TOS, then increments ESP. In other words, the stack grows down in
    memory toward lesser addresses." rel="popover"><code>%esp</code></a>+4+4*n.  

</p><p>

.code argint 
calls 
.code-index fetchint
to read the value at that address from user memory and write it to
.code *ip .  
.code fetchint 
can simply cast the address to a pointer, because the user and the
kernel share the same page table, but the kernel must verify that the
pointer lies within the user part of the address
space.
The kernel has set up the page-table hardware to make sure
that the process cannot access memory outside its local private memory:
if a user program tries to read or write memory at an address of
.code-index p->sz 
or above, the processor will cause a segmentation trap, and trap will
kill the process, as we saw above.
The kernel, however,
can derefence any address that the user might have passed, so it must check explicitly that the address is below
.code p->sz .

</p><p>

.code-index argptr
fetches the
.italic n th 
system call argument and checks that this argument is a valid
user-space pointer.
Note that two checks occur during a call to 
.code argptr .
First, the user stack pointer is checked during the fetching
of the argument.
Then the argument, itself a user pointer, is checked.

</p><p>

.code-index argstr 
interprets the
.italic n th 
argument as a pointer.  It ensures that the pointer points at a
NUL-terminated string and that the complete string is located below
the end of the user part of the address space.

</p><p>

Finally,
.code-index argfd
.line sysfile.c:/^argfd/
uses
.code argint
to retrieve a file descriptor number, checks if it is valid
file descriptor, and returns the corresponding
.code struct
.code file .

</p><p>

The system call implementations (for example, sysproc.c and sysfile.c)
are typically wrappers: they decode the arguments using 
.code argint ,
.code argptr , 
and 
.code argstr
and then call the real implementations.
In chapter \*[CH:MEM],
.code sys_exec
uses these functions to get at its arguments.
<h3><p>§ Code: Interrupts</p></h3>

</p><p>

Devices on the motherboard can generate interrupts, and xv6 must set up
the hardware to handle these interrupts.
Devices usually interrupt in order to tell the kernel that some hardware
event has occured, such as I/O completion.
Interrupts are usually optional in the sense that the kernel could
instead periodically check (or "poll") the device hardware to check
for new events.
Interrupts are preferable to polling if the events are relatively
rare, so that polling would waste CPU time.
Interrupt handling shares some of the code already needed
for system calls and exceptions.

</p><p>

Interrupts are similar to system calls, except devices generate them
at any time.  There is hardware on the motherboard to signal the CPU
when a device needs attention (e.g., the user has typed a character on
the keyboard). We must program the device to generate an interrupt, and
arrange that a CPU receives the interrupt. 

</p><p>

Let's look at the timer device and timer interrupts.  We would like
the timer hardware to generate an interrupt, say, 100 times per
second so that the kernel can track the passage of time and so the
kernel can time-slice among multiple running processes.  The choice of
100 times per second allows for decent interactive performance while
not swamping the processor with handling interrupts.  

</p><p>

Like the x86 processor itself, PC motherboards have evolved, and the
way interrupts are provided has evolved too.  The early boards had a
simple programmable interrupt controler (called the PIC).
With the advent of multiprocessor PC boards, a new way of handling
interrupts was needed, because each CPU needs an interrupt controller
to handle interrupts sent to it, and there must be a method for
routing interrupts to processors.  This way consists of two parts: a
part that is in the I/O system (the IO APIC,
.code ioapic.c), 
and a part that is attached to each processor (the
local APIC, 
.code lapic.c).
Xv6 is designed for a
board with multiple processors: it ignores interrupts from the PIC, and
configures the IOAPIC and local APIC.

</p><p>

The IO APIC has a table and the processor can program entries in the
table through memory-mapped I/O.
During initialization, xv6 programs to map interrupt 0 to IRQ 0, and
so on, but disables them all.  Specific devices enable particular
interrupts and say to which processor the interrupt should be routed.
For example, xv6 routes keyboard interrupts to processor 0
.line console.c:/^consoleinit/ .
Xv6 routes disk interrupts to the highest numbered processor on the
system, as we will see below.

</p><p>

The timer chip is inside the LAPIC, so that each processor can receive
timer interrupts independently. Xv6 sets it up in
.code-index lapicinit
.line lapic.c:/^lapicinit/ .
The key line is the one that programs the timer
.line lapic.c:/lapicw.TIMER/ .
This line tells the LAPIC to periodically generate an interrupt at
.code-index IRQ_TIMER,
which is IRQ 0.
Line
.line lapic.c:/lapicw.TPR/
enables interrupts on a CPU's LAPIC, which will cause it to deliver
interrupts to the local processor.

</p><p>

A processor can control if it wants to receive interrupts through the
.code-index IF
flag in the
<a class="popoverOption" data-content="The status flags of the EFLAGS register allow the results of one
    instruction to influence later instructions. The arithmetic
    instructions use OF, SF, ZF, AF, PF, and CF. The SCAS (Scan String),
    CMPS (Compare String), and LOOP instructions use ZF to signal that
    their operations are complete. There are instructions to set, clear,
    and complement CF before execution of an arithmetic instruction. Refer
    to Appendix C for definition of each status flag." rel="popover"><code>%eflags</code></a>
register.
The instruction
.code-index cli
disables interrupts on the processor by clearing 
.code IF , 
and
.code-index sti
enables interrupts on a processor.  Xv6 disables interrupts during
booting of the main cpu
.line bootasm.S:/cli/
and the other processors
.line entryother.S:/cli/ .
The scheduler on each processor enables interrupts
.line proc.c:/sti/ .
To control that certain code fragments are not interrupted, xv6
disables interrupts during these code fragments (e.g., see
.code-index switchuvm
.line vm.c:/^switchuvm/ ).

</p><p>

The timer interrupts through vector 32 (which xv6 chose to handle IRQ
0), which xv6 setup in
.code-index idtinit 
.line main.c:/idtinit/ .
The only difference between vector 32 and vector 64 (the one for
system calls) is that vector 32 is an interrupt gate instead of a trap
gate.  Interrupt gates clear
.code IF ,
so that the interrupted processor doesn't receive interrupts while it
is handling the current interrupt.  From here on until
.code-index trap , 
interrupts follow
the same code path as system calls and exceptions, building up a trap frame.

</p><p>

.code Trap
for a timer interrupt does just two things:
increment the ticks variable 
.line trap.c:/ticks!+!+/ , 
and call
.code-index wakeup . 
The latter, as we will see in Chapter \*[CH:SCHED], may cause the
interrupt to return in a different process.
.ig
Turns out our kernel had a subtle security bug in the way it handled traps... vb 0x1b:0x11, run movdsgs, step over breakpoints that aren't mov ax, ds, dump_cpu and single-step. dump_cpu after mov gs, then vb 0x1b:0x21 to break after sbrk returns, dump_cpu again.
..
.ig
point out that we are trying to be manly with interrupts, by turning them on often in the kernel.  probably would be just fine to turn them on only when the kernel is idle.
..
<h3><p>§ Drivers</p></h3>
A
.italic-index driver
is the code in an operating system that manages a particular device:
it tells the device hardware to perform operations,
configures the device to generate interrupts when done,
and handles the resulting interrupts.
Driver code can be tricky to write
because a driver executes concurrently with the device that it manages.  In
addition, the driver must understand the device's interface (e.g., which I/O
ports do what), and that interface can be complex and poorly documented.

</p><p>

The disk driver provides a good example.  The disk driver copies data
from and back to the disk.  Disk hardware traditionally presents the data on the
disk as a numbered sequence of 512-byte 
.italic blocks 
.index block
(also called 
.italic sectors ): 
.index sector
sector 0 is the first 512 bytes, sector 1 is the next, and so on. The block size
that an operating system uses for its file system maybe different than the
sector size that a disk uses, but typically the block size is a multiple of the
sector size.  Xv6's block size is identical to the disk's sector size.  To
represent a block xv6 has a structure
.code "struct buf"
.line buf.h:/^struct.buf/ .
The
data stored in this structure is often out of sync with the disk: it might have
not yet been read in from disk (the disk is working on it but hasn't returned
the sector's content yet), or it might have been updated but not yet written
out.  The driver must ensure that the rest of xv6 doesn't get confused when the
    structure is out of sync with the disk.
    
<h3><p>§ Code: Disk driver</p></h3>
</p><p>

The IDE device provides access to disks connected to the
PC standard IDE controller.
IDE is now falling out of fashion in favor of SCSI and SATA,
but the interface is simple and lets us concentrate on the
overall structure of a driver instead of the details of a
particular piece of hardware.

</p><p>

Xv6 represent file system blocks using
.code-index "struct buf"
.line buf.h:/^struct.buf/ .
.code BSIZE
.line fs.h:/BSIZE/
is identical to the IDE's sector size and thus
each buffer represents the contents of one sector on a particular
disk device.  The
.code dev
and
.code sector
fields give the device and sector
number and the
.code data
field is an in-memory copy of the disk sector.
Although the xv6 file system chooses
.code BSIZE
to be identical to the IDE's sector size, the driver can handle
a
.code BSIZE
that is a multiple of the sector size. Operating systems often use
bigger blocks than 512 bytes to obtain higher disk throughput.

</p><p>

The
.code flags
track the relationship between memory and disk:
the
.code-index B_VALID
flag means that
.code data
has been read in, and
the 
.code-index B_DIRTY 
flag means that
.code data
needs to be written out.

</p><p>

The kernel initializes the disk driver at boot time by calling
.code-index ideinit
.line ide.c:/^ideinit/
from
.code-index main
.line main.c:/ideinit/ .
.code Ideinit
calls
.code-index ioapicenable
to enable the
.code-index IDE_IRQ
interrupt
.line ide.c:/ioapicenable/ .
The call to
.code ioapicenable
enables the interrupt only on the last CPU
.code ncpu-1 ): (
on a two-processor system, CPU 1 handles disk interrupts.

</p><p>

Next,
.code-index ideinit
probes the disk hardware.
It begins by calling
.code-index idewait
.line ide.c:/idewait.0/
to wait for the disk to
be able to accept commands.
A PC motherboard presents the status bits of the disk hardware on I/O port
.address 0x1f7 .
.code Idewait
.line ide.c:/^idewait/
polls the status bits until the busy bit
.code-index IDE_BSY ) (
is clear and the ready bit
.code-index IDE_DRDY ) (
is set.

</p><p>

Now that the disk controller is ready,
.code ideinit
can check how many disks
are present.
It assumes that disk 0 is present,
because the boot loader and the kernel
were both loaded from disk 0,
but it must check for disk 1.
It writes to I/O port
.address 0x1f6
to select disk 1
and then waits a while for the status bit to show
that the disk is ready
.lines ide.c:/Check.if.disk.1/,/^..}/ .
If not, 
.code ideinit
assumes the disk is absent.

</p><p>

After
.code ideinit ,
the disk is not used again until the buffer cache calls
.code-index iderw ,
which updates a locked buffer
as indicated by the flags.
If
.code-index B_DIRTY
is set,
.code iderw
writes the buffer
to the disk; if
.code-index B_VALID
is not set,
.code-index iderw
reads the buffer from the disk.

</p><p>

Disk accesses typically take milliseconds,
a long time for a processor.
The boot loader
issues disk read commands and reads the status
bits repeatedly until the data is ready (see Appendix \*[APP:BOOT]).
This 
.italic-index polling 
or 
.italic-index "busy waiting"
is fine in a boot loader, which has nothing better to do.
In an operating system, however, it is more efficient to
let another process run on the CPU and arrange to receive
an interrupt when the disk operation has completed.
.code Iderw
takes this latter approach,
keeping the list of pending disk requests in a queue
and using interrupts to find out when each request has finished.
Although
.code iderw
maintains a queue of requests,
the simple IDE disk controller can only handle
one operation at a time.
The disk driver maintains the invariant that it has sent
the buffer at the front of the queue to the disk hardware;
the others are simply waiting their turn.

</p><p>

.code Iderw
.line ide.c:/^iderw/
adds the buffer
.code b
to the end of the queue
.lines ide.c:/Append/,/pp.=.b/ .
If the buffer is at the front of the queue,
.code-index iderw
must send it to the disk hardware
by calling
.code-index idestart
.line ide.c:/Start.disk/,/idestart/ ;
otherwise the buffer will be started once
the buffers ahead of it are taken care of.

</p><p>

.code Idestart
.line ide.c:/^idestart/
issues either a read or a write for the buffer's device and sector,
according to the flags.
If the operation is a write,
.code idestart
must supply the data now
.line ide.c:/outsl/ .
.code idestart
moves the data to a buffer in the disk controller
using the
.code outsl
instruction; 
using CPU instructions to move data to/from device hardware
is called programmed I/O.
Eventually the disk hardware will raise an
interrupt to signal that the data has been written to disk.
If the operation is a read, the interrupt will signal that the
data is ready, and the handler will read it.
Note that
.code-index idestart
has detailed knowledge about the IDE device, and writes the right values at the
right ports.  If any of these 
.code outb
statements is wrong, the IDE will do something differently than what we want.
Getting these details right is one reason why writing device drivers is
challenging.

</p><p>

Having added the request to the queue and started it if necessary,
.code iderw
must wait for the result.  As discussed above,
polling does not make efficient use of the CPU.
Instead,
.code-index iderw
yields the CPU for other processes by sleeping,
waiting for the interrupt handler to 
record in the buffer's flags that the operation is done
.lines ide.c:/while.*VALID/,/sleep/ .
While this process is sleeping,
xv6 will schedule other processes to keep the CPU busy.

</p><p>

Eventually, the disk will finish its operation and trigger an interrupt.
.code-index trap
will call
.code-index ideintr
to handle it
.line trap.c:/ideintr/ .
.code Ideintr
.line ide.c:/^ideintr/
consults the first buffer in the queue to find
out which operation was happening.
If the buffer was being read and the disk controller has data waiting,
.code ideintr
reads the data from a buffer in the disk controller
into memory with
.code-index insl
.lines ide.c:/Read.data/,/insl/ .
Now the buffer is ready:
.code ideintr
sets 
.code-index B_VALID ,
clears
.code-index B_DIRTY ,
and wakes up any process sleeping on the buffer
.lines ide.c:/Wake.process/,/wakeup/ .
Finally,
.code ideintr
must pass the next waiting buffer to the disk
.lines ide.c:/Start.disk/,/idestart/ .
.\"
.section "Real world"
.\"
Supporting all the devices on a PC motherboard in its full glory is much work,
because there are many devices, the devices have many features, and the protocol
between device and driver can be complex.  In many operating systems, the
drivers together account for more code in the operating system than the core
kernel.

</p><p>

Actual device drivers are far more complex than the disk driver in this chapter,
but the basic ideas are the same:
typically devices are slower than CPU, so the hardware uses
interrupts to notify the operating system of status changes.
Modern disk controllers typically
accept a 
.italic-index batch 
of disk requests at a time and even reorder
them to make most efficient use of the disk arm.
When disks were simpler, operating systems often reordered the
request queue themselves.

</p><p>
 
Many operating systems have drivers for solid-state disks because they provide
much faster access to data.  But, although a solid-state disk works very differently
from a traditional mechanical disk, both devices provide block-based interfaces
and reading/writing blocks on a solid-state disk is still more expensive than
reading/writing RAM.

</p><p>

Other hardware is surprisingly similar to disks: network device buffers
hold packets, audio device buffers hold sound samples, graphics card
buffers hold video data and command sequences.
High-bandwidth devices—disks, graphics cards, and network cards—often use
direct memory access (DMA) instead of programmed I/O
.opcode insl , (
.opcode outsl ).
DMA allows the device direct access to physical memory.
The driver gives the device the physical address of the buffer's data and
the device copies directly to or from main memory,
interrupting once the copy is complete.
DMA is faster and more efficient than programmed I/O
and is less taxing for the CPU's memory caches.

</p><p>

Some drivers dynamically switch between polling and interrupts, because using
interrupts can be expensive, but using polling can introduce delay until the
driver processes an event.  For example, a network driver that receives a
burst of packets may switch from interrupts to polling since it knows that more
packets must be processed and it is less expensive to process them using polling.
Once no more packets need to be processed, the driver may switch back to
interrupts, so that it will be alerted immediately when a new packet arrives.

</p><p>

The IDE driver routes interrupts statically to a particular processor.  Some
drivers configure the IO APIC
to route interrupts to multiple processors to spread out
the work of processing packets.
For example, a network driver might arrange to deliver interrupts
for packets of one network connection to the processor that is managing that
connection, while interrupts for packets of another connection are delivered to
another processor.  This routing can get quite sophisticated; for example, if
some network connections are short lived while others are long lived and the
operating system wants to keep all processors busy to achieve high throughput.

</p><p>

If a program reads a file, the data for that file is copied twice.  First, it
is copied from the disk to kernel memory by the driver, and then later it is
copied from kernel space to user space by the 
.code read
system call.  If the program then sends the data over the network, 
the data is copied twice more: from user space to kernel space and from
kernel space to the network device.  To support applications for which 
efficiency is important (e.g., serving popular images on the Web), operating systems
use special code paths to avoid copies.  As one example,
in real-world operating systems, 
buffers typically match the hardware page size, so that
read-only copies can be mapped into a process's address space
using the paging hardware, without any copying.
  </p>
  
  <h3><p>§ Exercises</p></h3>

  <p>

    1. Set a breakpoint at the first instruction of
    <code>syscall</code> to catch the very first system call (e.g., br
    syscall). What values are on the stack at this point?  Explain the
    output of x/37x $esp at that breakpoint with each value labeled as to
    what it is (e.g., saved <a class="popoverOption" data-content="The stack-frame base pointer (EBP) register. The EBP is the best
    choice of register for accessing data structures, variables and
    dynamically allocated work space within the stack. EBP is often used
    to access elements on the stack relative to a fixed point on the stack
    rather than relative to the current TOS. It typically identifies the
    base address of the current stack frame established for the current
    procedure. When EBP is used as the base register in an offset
    calculation, the offset is calculated automatically in the current
    stack segment (i.e., the segment currently selected by SS). Because SS
    does not have to be explicitly specified, instruction encoding in such
    cases is more efficient. EBP can also be used to index into segments
    addressable via other segment registers." rel="popover"><code>%ebp</code></a> for trap, trapframe.eip, scratch space,
    etc.).
  </p>
  <p>
    2.  Add a new system call to get the current UTC time and return it to the user
    program. You may want to use the helper function, <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(7552);">cmostime</a></code>,
    to read the real time clock. The file <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(950);">date.h</a></code> contains the definition
    of the <code>struct rtcdate</code>, which you will provide as an argument to
    <code><a onclick="event.stopPropagation()" href="javascript:gotoLine(7552);">cmostime</a></code> as a pointer.
  </p>

  <p>
    3. Write a driver for a disk that supports the SATA standard
    (search for SATA on the Web). Unlike IDE, SATA isn't obsolete.  Use
    SATA's tagged command queuing to issue many commands to the disk so
    that the disk internally can reorder commands to obtain high
    performance.
  </p>

  <p>
    4. Add simple driver for an Ethernet card.
  </p>  
</div>
--!>
          
          <footer class="footer">
            <div class="container">
              <p class="text-muted">Place sticky footer content here.</p>
            </div>
          </footer>
          
          </div>          
        </div>
      </div>

    </div>

    
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <!-- <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script> -->
    <script
  src="https://code.jquery.com/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    
    <!-- <script src="js/ace-builds/src-noconflict/ace.js" type="text/javascript" charset="utf-8"></script> -->
    <script src="js/ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="js/debug-src-list.js" type="text/javascript" charset="utf-8"></script>
    <script src="js/paragraph.js" type="text/javascript" charset="utf-8"></script>
    <script src="js/dialog.js" type="text/javascript" charset="utf-8"></script>

    <script>
      var lastMarker = false;
      
      function gotoLine(n) {
          var Range = ace.require('ace/range').Range;
          let r = new Range(n-1, 0, n-1, 100);
          if (lastMarker) {
              editor.session.removeMarker(lastMarker);
          }
          lastMarker = editor.session.addMarker(r, "myMarker", "fullLine");
          editor.scrollToLine(n, true, true);
      }

      function gotoLines(from, to) {
          var Range = ace.require('ace/range').Range;
          let r = new Range(from-1, 0, to-1, 100);
          if (lastMarker) {
              editor.session.removeMarker(lastMarker);
          }
          lastMarker = editor.session.addMarker(r, "myMarker", "fullLine");
          editor.scrollToLine(from, true, true);
      }
      
      $(window).resize(function() {
          $("#editor").css("height", window.innerHeight);
          console.log("resizing window");
      });
    </script>
    
    <script>
      var editor = ace.edit("editor");
      editor.setValue("downloaded xv6 src, this could take a couple seconds.", 1);
      editor.setValue(xv6SrcList.join("\n"), 1);
      editor.setAnimatedScroll(true);
      editor.setTheme("ace/theme/solarized_light");      
      editor.session.setMode("ace/mode/c_cpp");
      editor.setReadOnly(true);
      editor.setHighlightActiveLine(true);
      $("#editor").css("height", window.innerHeight);
      setTimeout("gotoLine(1000);", 200);
      
    </script>
    
    <script>
      $(function () {
          $('[data-toggle="popover"]').popover({
              placement: 'left',
              html:true,
              offset: '200px',
          })
      })

      $("#popover").popover({ trigger: "hover" });

      $('#popoverOption').popover({
          trigger: "hover",
          placement: 'left',
          html:true
      });

      $('.popoverOption').popover({
          trigger: "hover",
          placement: 'left',
          html:true
      });
      
      $('p').hover(
          function(p) {
              p.target.style.backgroundColor = "#f8f8f8"
          },
          function(p){ 
              p.target.style.backgroundColor = "#fff"
          })
    </script>

    
  </body>
</html>
